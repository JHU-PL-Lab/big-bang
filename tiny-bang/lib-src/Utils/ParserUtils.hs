{-# LANGUAGE FlexibleContexts, ScopedTypeVariables, ViewPatterns,
             TemplateHaskell #-}

module Utils.ParserUtils
(

(<$&>),
coverRegion,
argreg1,
argreg2,
argreg3,
argorig1,
argorig2,
argorig3,
regionOf,
startLoc,
stopLoc,
) where


import Control.Applicative ((<$>))
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.Reader

import Text.Parsec.Prim
import Text.Parsec.Pos
import Language.TinyBang.Utils.Parsec
import Language.TinyBang.Ast.Data
import Language.TinyBang.Syntax.Lexer
import Language.TinyBang.Display
import Language.TinyBang.Syntax.Location

-- | Todo: could generalize Parsers, make type class for tokens, etc to pull out more code
-- | common to parsers

-- |An operator which uncurries and applies a monadic operation.  It accepts a
--  non-monadic function @a -> b -> c@ and a monadic pair @m (a,b)@ and provides
--  a monadic result @m c@.
(<$&>) :: (Monad m) => (a -> b -> c) -> m (a, b) -> m c
(<$&>) f p = do
    (x,y) <- p
    return $ f x y

-- |A utility function to create a region from two HasOrigin arguments.
coverRegion :: (Display a, Display b, HasOrigin a, HasOrigin b)
                => a -> b -> SourceRegion
coverRegion a b = SourceRegion (startLoc a) (stopLoc b)
                                     
-- |A wrapper to automatically extract source regions.  This function accepts
--  another function which expects a source region and one other argument; it
--  also accepts that argument.  The function is called with the region of the
--  argument.
argreg1 :: (Display a1, HasOrigin a1) => (SourceRegion -> a1 -> r) -> a1 -> r
argreg1 f a1 = f (regionOf a1) a1

-- |A wrapper to automatically extract source regions.  This function accepts
--  another function which expects a source region and two other arguments; it
--  also accepts those two arguments.  The function is called with a region
--  starting at the start of the first argument and stopping at the stop of the
--  second argument.
argreg2 :: (Display a1, Display a2, HasOrigin a1, HasOrigin a2)
        => (SourceRegion -> a1 -> a2 -> r) -> a1 -> a2 -> r
argreg2 f a1 a2 = f (coverRegion a1 a2) a1 a2

-- |A wrapper to automatically extract source regions.  This function accepts
--  another function which expects a source region and three other arguments; it
--  also accepts those three arguments.  The function is called with a region
--  starting at the start of the first argument and stopping at the stop of the
--  third argument.
argreg3 :: (Display a1, Display a3, HasOrigin a1, HasOrigin a3)
        => (SourceRegion -> a1 -> a2 -> a3 -> r) -> a1 -> a2 -> a3 -> r
argreg3 f a1 a2 a3 = f (coverRegion a1 a3) a1 a2 a3

argorig1 :: (Display a1, HasOrigin a1) => (Origin -> a1 -> r) -> a1 -> r
argorig1 f = argreg1 $ \x -> f (SourceOrigin x)

argorig2 :: (Display a1, Display a2, HasOrigin a1, HasOrigin a2)
         => (Origin -> a1 -> a2 -> r) -> a1 -> a2 -> r
argorig2 f = argreg2 $ \x -> f (SourceOrigin x)

argorig3 :: (Display a1, Display a3, HasOrigin a1, HasOrigin a3)
         => (Origin -> a1 -> a2 -> a3 -> r) -> a1 -> a2 -> a3 -> r
argorig3 f = argreg3 $ \x -> f (SourceOrigin x)


-- |Extracts the region from an entity which has a source origin.  If
--  the argument has a non-source origin, this function will error.  All AST
--  nodes generated by the parser have source origins.
regionOf :: (Display a, HasOrigin a) => a -> SourceRegion
regionOf x = case originOf x of
    SourceOrigin region -> region
    _ -> error $ "regionOf called on non-source origin " ++ display x

-- |Extracts the start location from an entity which has a source origin.  If
--  the argument has a non-source origin, this function will error.  All AST
--  nodes generated by the parser have source origins.
startLoc :: (Display a, HasOrigin a) => a -> SourceLocation
startLoc (regionOf -> SourceRegion start _) = start 

-- |Extracts the stop location from an entity which has a source origin.  If
--  the argument has a non-source origin, this function will error.  All AST
--  nodes generated by the parser have source origins.
stopLoc :: (Display a, HasOrigin a) => a -> SourceLocation
stopLoc (regionOf -> SourceRegion _ stop) = stop


