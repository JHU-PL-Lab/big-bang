{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Paths_tiny_bang (version) -- Generated by Cabal
import Data.Version (showVersion)

import Data.List.Split
import System.Console.CmdArgs
import System.IO (hFlush, stdout)

import Executables.Interpreter.SourceInterpreter

data Options = Options
  { noTypecheck :: Bool
  , noEval :: Bool
  } deriving (Data, Typeable, Show, Eq)
  
defOpts :: Options
defOpts = Options { noTypecheck = def
                        &= name "T"
                        &= help "Disables typechecker"
                  , noEval = def
                        &= name "E"
                        &= help "Disables evaluator"
                  }
          &= program "interpreter"
          &= summary versionStr
          
versionStr :: String
versionStr = "TinyBang Interpreter version " ++ showVersion version

-- |Enters a toploop in which source code is read and executed.  Each expression
--  is delimited by two semicolons in the fashion of OCaml.
toploop :: Options -> IO ()
toploop opts = do
  inp <- getContents
  let exprSrcs = filter (not . null) $ splitOn ";;" inp
  mapM_ doEvalPrint exprSrcs
  where
    doEvalPrint :: String -> IO ()
    doEvalPrint exprSrc = do
      putStrLn $ stringyInterpretSource
                  InterpreterConfiguration
                    { typechecking = not $ noTypecheck opts
                    , evaluating = not $ noEval opts }
                  exprSrc
      putStr "# "
      hFlush stdout
      
-- |Executes the TinyBang interpreter.
main :: IO ()
main = do
  opts <- cmdArgs defOpts
  putStrLn versionStr
  putStrLn ""
  putStr "# "
  hFlush stdout
  toploop opts
