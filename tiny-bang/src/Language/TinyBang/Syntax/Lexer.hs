module Language.TinyBang.Syntax.Lexer
( lexTinyBang
, Token(..)
, PositionalToken(..)
, TextPosition(..)
) where

import Text.ParserCombinators.Parsec

import Control.Applicative((<$>), (<*>), (<*), (*>), pure)

-- |The raw tokens generated by this lexer.
data Token
  = TokIs -- ^@=@
  | TokGets -- ^@<-@
  | TokThrows -- ^@throws@
  | TokDef -- ^@:=@
  | TokFlows -- ^@<~@
  | TokPlus -- ^@+@
  | TokMinus -- ^@-@
  | TokLT -- ^@<@
  | TokGT -- ^@>@
  | TokEq -- ^@==@
  | TokEmptyOnion -- ^@()@
  | TokOnion -- ^@&@
  | TokOnionSub -- ^@&-@
  | TokOnionProj -- ^@&.@
  | TokArrow -- ^@->@
  | TokImmut -- ^@immut@
  | TokFinal -- ^@final@
  | TokExn -- ^@exn@
  | TokFun -- ^@fun@
  | TokInt -- ^@int@
  | TokChar -- ^@char@
  | TokColon -- ^@:@
  | TokIdentifier String
  | TokLitInt Integer
  | TokLitChar Char
  | TokLabel String -- ^The @String@ is only the name of the label, not the @`@

-- |Defines a data type for text positions.  The @lineNo@ is one-based; the
--  @colNo@ is zero-based.
data TextPosition = TextPosition { lineNo :: Int
                                 , colNo :: Int }

  
-- |An annotation for tokens which describes their location.  Both @startPos@
--  and @stopPos@ are exclusive.
data PositionalToken
  = PositionalToken { startPos :: TextPosition
                    , stopPos :: TextPosition
                    , posToken :: Token }
                    
-- |Converts a Parsec location representation to a @TextPosition@
sourcePosToTextPosition :: SourcePos -> TextPosition
sourcePosToTextPosition pos =
  TextPosition { lineNo = sourceLine pos, colNo = sourceColumn pos }

-- | The TinyBang lexer type.
type Lexer a = GenParser Char () a

-- | A function to lex a @String@ containing TinyBang code.  On error, the
--   result is a left error string; otherwise, it is a right positional token
--   list.
lexTinyBang :: String -> Either String [PositionalToken]
lexTinyBang src =
  case parse tinyBangLexer "<source>" src of
    Left x -> Left $ show x
    Right x -> Right x

-- | A lexer which obtains all tokens in a given stream
tinyBangLexer :: Lexer [PositionalToken]
tinyBangLexer = spaces *> many (tinyBangPosTokenLexer <* spaces) <* eof

-- | A lexer which obtains a single positional token from a stream
tinyBangPosTokenLexer :: Lexer PositionalToken
tinyBangPosTokenLexer = do
  (start,tok,stop) <- (,,) <$> getPosition <*> tinyBangTokenLexer <*> getPosition
  return $ PositionalToken
            (sourcePosToTextPosition start)
            (sourcePosToTextPosition stop) tok

-- | A lexer which obtains a single token from a stream
tinyBangTokenLexer :: Lexer Token
tinyBangTokenLexer = choice $ map try $
  concat [operators, reservedWords, variableLengthLexers]

-- | A lexer which matches a character which may appear within an identifier.
identChar :: Lexer Char
identChar = alphaNum <|> char '_'

-- | A lexer which matches a character which may start an identifier.
identStartChar :: Lexer Char
identStartChar = letter <|> char '_'

-- | This group of lexers matches all operators.
operators :: [Lexer Token]
operators = map (\(s,t) -> string s *> pure t)
    [ ("&-", TokOnionSub)
    , ("&.", TokOnionProj)
    , ("->", TokArrow)
    , ("<-", TokGets)
    , (":=", TokDef)
    , ("<~", TokFlows)
    , ("==", TokEq)
    , ("()", TokEmptyOnion)
    , ("+", TokPlus)
    , ("-", TokMinus)
    , ("<", TokLT)
    , (">", TokGT)
    , ("&", TokOnion)
    , (":", TokColon)
    , ("=", TokIs)
    ]

-- | This group of lexers matches all reserved words.
reservedWords :: [Parser Token]
reservedWords =
  map (\(s, t) -> string s *> notFollowedBy identChar *> pure t)
    [ ("throws", TokThrows)
    , ("immut" , TokImmut)
    , ("final" , TokFinal)
    , ("exn"   , TokExn)
    , ("fun"   , TokFun)
    , ("int"   , TokInt)
    , ("char"  , TokChar)
    ]

-- | This group of lexers matches parametric tokens.
variableLengthLexers :: [Parser Token]
variableLengthLexers =
  [ identifierLexer
  , labelLexer
  , integerLexer
  , characterLexer
  ]
  where
    identifierLexer = TokIdentifier .: (:) <$> identStartChar <*> many identChar
    labelLexer = TokLabel .: (:) <$>
      (char '`' *> identStartChar) <*> many identChar
    integerLexer = TokLitInt . read .: (:) <$>
      option ' ' (char '-') <*> many1 digit <* notFollowedBy identChar
    characterLexer = TokLitChar <$> between (char '\'') (char '\'') anyChar
    -- |A convenient operator for composing a unary operator with a binary one.
    (.:) = (.) . (.)
    infixr 8 .:
    