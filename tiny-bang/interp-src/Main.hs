{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Paths_tiny_bang (version) -- Generated by Cabal
import Data.Version (showVersion)

import Control.Monad
import System.Console.CmdArgs
import System.IO (hFlush, stdout)

import Language.TinyBang.Toploop
import Language.TinyBang.Utils.Assertions
import Utils.Toploop
import Utils.Toploop.Logging

--import Lanugage.TinyBang.ToploopBM
--import Language.TinyBang.Communicator
--import Language.TinyBang.Communnicator.FromHaskellObject
import Data.List.Split

data Options = Options
  { noTypecheck :: Bool
  , noEval :: Bool
  , loggingInstructions :: [String]
  , databaseName :: String
  , batchMode :: Bool 
  , assertions :: Bool
  } deriving (Data, Typeable, Show, Eq)
  
defOpts :: Options
defOpts = Options { noTypecheck = def
                        &= name "T"
                        &= explicit
                        &= help "Disables typechecker."
                  , noEval = def
                        &= name "E"
                        &= explicit
                        &= help "Disables evaluator."
                  , loggingInstructions = def
                        &= name "log"
                        &= explicit
                        &= help ("Configures logging levels.  Each logging "
                              ++ "instruction is either a logging level (one "
                              ++ "of debug, info, notice, warning, error, or "
                              ++ "critical) or a Haskell module hierarchy name "
                              ++ "followed by a colon and a logging level.")
                  , databaseName = def
                        &= name "db"
                        &= explicit
                        &= help ("Selects the constraint database "
                              ++ "implementation.  This must be one of the "
                              ++ "following: "
                              ++ "[simple] indexed")
                  , batchMode = def
                        &= name "batch-mode"
                        &= explicit
                        &= help "Performs batch mode operations."
                  , assertions = def
                        &= name "enable-assertions"
                        &= name "ea"
                        &= name "A"
                        &= explicit
                        &= help ("Enables assertion checking.  This will only "
                              ++ "function correctly if assertions were "
                              ++ "compiled into this binary.")
                  }
          &= program "interpreter"
          &= summary versionStr
          
versionStr :: String
versionStr = "TinyBang Interpreter version " ++ showVersion version

-- |Creates an evaluation routine for a single expression.  Requires an initial
--  configuration.
makeEval :: Options -> IO (String -> IO String)
makeEval opts = do
  dtype <- case typeFromName $ databaseName opts of
    Just t -> return t
    Nothing -> ioError $ userError
                      $ "Invalid database name: " ++ databaseName opts
  let config = InterpreterConfiguration
                    { typechecking = not $ noTypecheck opts
                    , evaluating = not $ noEval opts
                    , databaseType = dtype }
  return $ return . stringyInterpretSource config
  where
    typeFromName dbname = case dbname of
      "simple" -> Just Simple
      "indexed" -> Just Indexed
      "" -> Just Simple -- default if none is specified
      _ -> Nothing

-- |Executes the TinyBang interpreter.
main :: IO ()
main = do
  opts <- cmdArgs defOpts
  
  configurationSuccessful <- configureLogging $ loggingInstructions opts
  unless configurationSuccessful $
    ioError $ userError "Logging configuration failed."
  configureLoggingHandlers
  
  when (assertions opts) $ do
    enableAssertions
    putStrLn "Assertions enabled!"
  
  if batchMode opts     
    then do 
      
      inp <- getContents
      -- |Method for batchMode
  
      let exprSrcs = filter (not . null) $ splitOn ";;" inp
          config = InterpreterConfiguration
                     { typechecking = not $ noTypecheck opts
                     , evaluating = not $ noEval opts
                     , databaseType = Simple }                
      mapM_ (putStrLn . stringyInterpretSource config) exprSrcs      
      
    else do 
      putStrLn versionStr
      putStrLn ""
      putStrLn "###"
      hFlush stdout
  
      eval <- makeEval opts
      toploop eval

