{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Paths_tiny_bang (version) -- Generated by Cabal
import Data.Version (showVersion)

import Control.Monad (unless)
import System.Console.CmdArgs
import System.IO (hFlush, stdout)

import Language.TinyBang.Toploop
import Utils.Toploop
import Utils.Toploop.Logging

-- package for testing
import Language.TinyBang.ToploopTest as TLT
import Data.List.Split
import qualified Data.ByteString.Lazy.Char8 as BL

data Options = Options
  { noTypecheck :: Bool
  , noEval :: Bool
  , loggingInstructions :: [String]
  , databaseName :: String
  , batchMode :: Bool  
  } deriving (Data, Typeable, Show, Eq)
  
defOpts :: Options
defOpts = Options { noTypecheck = def
                        &= name "T"
                        &= explicit
                        &= help "Disables typechecker."
                  , noEval = def
                        &= name "E"
                        &= explicit
                        &= help "Disables evaluator."
                  , loggingInstructions = def
                        &= name "log"
                        &= explicit
                        &= help ("Configures logging levels.  Each logging "
                              ++ "instruction is either a logging level (one "
                              ++ "of debug, info, notice, warning, error, or "
                              ++ "critical) or a Haskell module hierarchy name "
                              ++ "followed by a colon and a logging level.")
                  , databaseName = def
                        &= name "db"
                        &= explicit
                        &= help ("Selects the closure database.  This "
                              ++ "must be one of the following: "
                              ++ "simple")
                  , batchMode = def
                        &= name "batch-mode"
                        &= explicit
                        &= help "Performs batch mode operations."
                  }
          &= program "interpreter"
          &= summary versionStr
          
versionStr :: String
versionStr = "TinyBang Interpreter version " ++ showVersion version

-- |Creates an evaluation routine for a single expression.  Requires an initial
--  configuration.
makeEval :: Options -> IO (String -> IO String)
makeEval opts = do
  dtype <- case typeFromName $ databaseName opts of
    Just t -> return t
    Nothing -> ioError $ userError
                      $ "Invalid database name: " ++ databaseName opts
  let config = InterpreterConfiguration
                    { typechecking = not $ noTypecheck opts
                    , evaluating = not $ noEval opts
                    , databaseType = dtype }
  return $ return . stringyInterpretSource config
  where
    typeFromName dbname = case dbname of
      "simple" -> Just Simple
      "" -> Just Simple -- default if none is specified
      _ -> Nothing

-- |Executes the TinyBang interpreter.
main :: IO ()
main = do
  opts <- cmdArgs defOpts
            
  configurationSuccessful <- configureLogging $ loggingInstructions opts
  unless configurationSuccessful $
    ioError $ userError "Logging configuration failed."
  configureLoggingHandlers

  if batchMode opts     
    then do 

      --putStrLn $ versionStr ++ " --Batch mode"
      --putStrLn ""
      --putStrLn "###"
      --hFlush stdout            

      -- | TODO change getLine to getContent
      getLine >>= \inp -> putStrLn . messageHandler $ inp

      --putStrLn "###"
      hFlush stdout
      
    else do 
      putStrLn versionStr
      putStrLn ""
      putStrLn "###"
      hFlush stdout
  
      eval <- makeEval opts
      toploop eval
       
