{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Paths_tiny_bang (version) -- Generated by Cabal
import Data.Version (showVersion)

import Control.Monad (unless)
import Data.List.Split
import System.Console.CmdArgs
import System.IO (hFlush, stdout)

import Interpreter.SourceInterpreter
import Logging

data Options = Options
  { noTypecheck :: Bool
  , noEval :: Bool
  , loggingInstructions :: [String]
  , databaseName :: String
  } deriving (Data, Typeable, Show, Eq)
  
defOpts :: Options
defOpts = Options { noTypecheck = def
                        &= name "T"
                        &= explicit
                        &= help "Disables typechecker."
                  , noEval = def
                        &= name "E"
                        &= explicit
                        &= help "Disables evaluator."
                  , loggingInstructions = def
                        &= name "log"
                        &= explicit
                        &= help ("Configures logging levels.  Each logging "
                              ++ "instruction is either a logging level (one "
                              ++ "of debug, info, notice, warning, error, or "
                              ++ "critical) or a Haskell module hierarchy name "
                              ++ "followed by a colon and a logging level.")
                  , databaseName = def
                        &= name "db"
                        &= explicit
                        &= help ("Selects the closure database.  This "
                              ++ "must be one of the following: "
                              ++ "simple")
                  }
          &= program "interpreter"
          &= summary versionStr
          
versionStr :: String
versionStr = "TinyBang Interpreter version " ++ showVersion version

-- |Enters a toploop in which source code is read and executed.  Each expression
--  is delimited by two semicolons in the fashion of OCaml.
toploop :: Options -> IO ()
toploop opts = do
  inp <- getContents
  let exprSrcs = filter (not . null) $ splitOn ";;" inp
  mapM_ doEvalPrint exprSrcs
  where
    doEvalPrint :: String -> IO ()
    doEvalPrint exprSrc = do
      dtype <- case typeFromName $ databaseName opts of
        Just t -> return t
        Nothing -> ioError $ userError $
                      "Invalid database name: " ++ databaseName opts
      putStrLn $ stringyInterpretSource
                  InterpreterConfiguration
                    { typechecking = not $ noTypecheck opts
                    , evaluating = not $ noEval opts
                    , databaseType = dtype }
                  exprSrc
      putStrLn "###"
      hFlush stdout
      where
        typeFromName dbname = case dbname of
          "simple" -> Just Simple
          "" -> Just Simple -- default if none is specified
          _ -> Nothing
      
-- |Executes the TinyBang interpreter.
main :: IO ()
main = do
  opts <- cmdArgs defOpts
  
  configurationSuccessful <- configureLogging $ loggingInstructions opts
  unless configurationSuccessful $
    ioError $ userError "Logging configuration failed."
  configureLoggingHandlers
  
  putStrLn versionStr
  putStrLn ""
  putStrLn "###"
  hFlush stdout
  
  toploop opts
