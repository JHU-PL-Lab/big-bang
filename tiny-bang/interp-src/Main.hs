{-# LANGUAGE DeriveDataTypeable #-}

module Main where

import Paths_tiny_bang (version) -- Generated by Cabal
import Data.Version (showVersion)

import Control.Monad (unless)
import Data.List.Split
import System.Console.CmdArgs
import System.IO (hFlush, stdout)

import Interpreter.SourceInterpreter
import Logging

data Options = Options
  { noTypecheck :: Bool
  , noEval :: Bool
  , loggingInstructions :: [String]
  } deriving (Data, Typeable, Show, Eq)
  
defOpts :: Options
defOpts = Options { noTypecheck = def
                        &= name "T"
                        &= explicit
                        &= help "Disables typechecker."
                  , noEval = def
                        &= name "E"
                        &= explicit
                        &= help "Disables evaluator."
                  , loggingInstructions = def
                        &= name "log"
                        &= explicit
                        &= help ("Configures logging levels.  Each logging "
                              ++ "instruction is either a logging level (one "
                              ++ "of debug, info, notice, warning, error, or "
                              ++ "critical) or a Haskell module hierarchy name "
                              ++ "followed by a colon and a logging level.")
                  }
          &= program "interpreter"
          &= summary versionStr
          
versionStr :: String
versionStr = "TinyBang Interpreter version " ++ showVersion version

-- |Enters a toploop in which source code is read and executed.  Each expression
--  is delimited by two semicolons in the fashion of OCaml.
toploop :: Options -> IO ()
toploop opts = do
  inp <- getContents
  let exprSrcs = filter (not . null) $ splitOn ";;" inp
  mapM_ doEvalPrint exprSrcs
  where
    doEvalPrint :: String -> IO ()
    doEvalPrint exprSrc = do
      putStrLn $ stringyInterpretSource
                  InterpreterConfiguration
                    { typechecking = not $ noTypecheck opts
                    , evaluating = not $ noEval opts }
                  exprSrc
      putStrLn "###"
      hFlush stdout
      
-- |Executes the TinyBang interpreter.
main :: IO ()
main = do
  opts <- cmdArgs defOpts
  
  configurationSuccessful <- configureLogging $ loggingInstructions opts
  unless configurationSuccessful $
    ioError $ userError "Logging configuration failed."
  configureLoggingHandlers
  
  putStrLn versionStr
  putStrLn ""
  putStrLn "###"
  hFlush stdout
  
  toploop opts
