{-|
  This module provides a Parsec lexer for the value DSL.
-}

module Test.TinyBang.ExpectDsl.Lexer
( lexValueDsl
, Token(..)
, PositionalToken(..)
) where

import Control.Applicative((<$>), (<*>), (<*), (*>), pure)
import Text.ParserCombinators.Parsec

import Text.Parsec.Prim (Parsec)

-- |The raw tokens generated by this lexer.
data Token
  = TokEmptyOnion -- ^@()@
  | TokOnion -- ^@&@
  | TokOpenParen -- ^@(@
  | TokCloseParen -- ^@)@
  | TokLitInt Integer
  | TokLitChar Char
  | TokLabel String -- ^The @String@ is only the name of the label, not the @`@
  | TokScapes -- ^@scapes@
  | TokTypeFail -- ^@typefail@
  deriving (Eq, Ord, Show)
  
-- |Parsec-annotated tokens.
data PositionalToken = PositionalToken SourcePos Token
  deriving (Eq, Ord, Show)

-- |The Lexer type.
type Lexer a = Parsec String () a

-- |A function to lex a @String@ containing the value DSL code.  On error, the
--  result is a left error string; otherwise, it is a right token list.
lexValueDsl :: String -> Either String [PositionalToken]
lexValueDsl src =
  case parse lexer "<input>" src of
    Left x -> Left $ show x
    Right x -> Right x

-- | A lexer which obtains all tokens in a given stream
lexer :: Lexer [PositionalToken]
lexer = nonTokens *> many (positionalTokenLexer <* nonTokens) <* eof

-- | A lexer which matches non-token content.
nonTokens :: Lexer ()
nonTokens = spaces

-- | A lexer which obtains a positional token from a stream.
positionalTokenLexer :: Lexer PositionalToken
positionalTokenLexer = do
  pos <- getPosition
  tok <- tokenLexer
  return $ PositionalToken pos tok

-- | A lexer which obtains a single token from a stream
tokenLexer :: Lexer Token
tokenLexer = choice $ map try $
  concat [variableLengthLexers, operators, reservedWords]

-- | This group of lexers matches all operators and similar symbols.
operators :: [Lexer Token]
operators = map (\(s,t) -> string s *> pure t)
    [ ("()", TokEmptyOnion)
    , ("&", TokOnion)
    , ("(", TokOpenParen)
    , (")", TokCloseParen)
    ]

-- | This group of lexers matches all reserved words.
reservedWords :: [Parser Token]
reservedWords =
  map (\(s, t) -> string s *> notFollowedBy identChar *> pure t)
    [ ("scapes", TokScapes)
    , ("typefail", TokTypeFail)
    ]

-- | This group of lexers matches parametric tokens.
variableLengthLexers :: [Parser Token]
variableLengthLexers =
  [ labelLexer
  , integerLexer
  , characterLexer
  ]
  where
    labelLexer = TokLabel .: (:) <$>
      (char '`' *> identStartChar) <*> many identChar
    integerLexer = TokLitInt . read .: (:) <$>
      option ' ' (char '-') <*> many1 digit <* notFollowedBy identChar
    characterLexer = TokLitChar <$> between (char '\'') (char '\'') anyChar
    -- |A convenient operator for composing a unary operator with a binary one.
    (.:) = (.) . (.)
    infixr 8 .:
    
-- | A lexer which matches a character which may appear within an identifier.
identChar :: Lexer Char
identChar = alphaNum <|> char '_'

-- | A lexer which matches a character which may start an identifier.
identStartChar :: Lexer Char
identStartChar = letter <|> char '_'
