#+TITLE: Roadmap

* Short term
** TODO Refactorings
*** TODO [[https://github.com/JHU-PL-Lab/big-bang/issues/1][Abstract over toploops]]
**** Base the abstraction on Big Bang lexer, parser and toploop
**** TODO Come back with command line options
***** It was extracted from Tiny Bang toploop
#+BEGIN_EXAMPLE
open Batteries;;

open Tiny_bang_ast_pretty;;
open Tiny_bang_ast_wellformedness;;
open Tiny_bang_interpreter;;
open Tiny_bang_toploop_options;;
open Tiny_bang_typechecker;;

type toploop_options = {
  toploop_typechecker_disabled : bool
};;

let toploop_operate toploop_options e =
  print_string "\n";
  begin
    try
      (* Check well-formedness. *)
      check_wellformed_expr e;
      (* Typecheck (if appropriate). *)
      if not @@ toploop_options.toploop_typechecker_disabled
      then assert_typesafe e
      else ();
      (* Evaluate. *)
      let v,env = eval e in
      print_string (pretty_var v ^ " where "  ^ pretty_env env ^ "\n");
    with
    | Illformedness_found(ills) ->
      print_string "Provided expression is ill-formed:\n";
      List.iter
        (fun ill ->
           print_string @@ "   " ^ pretty_illformedness ill ^ "\n")
        ills
    | Typecheck_error ->
      print_string "Typechecking error discovered.\n"
  end;
  print_string "\n";
  print_string "Please enter an expression to evaluate followed by \";;\".\n";
  print_string "\n";
  flush stdout
;;

let command_line_parsing () =
  let parser = BatOptParse.OptParser.make ~version:"version 0.3" () in
  BatOptParse.OptParser.add parser
    ~long_name:"log"
    logging_option;
  BatOptParse.OptParser.add parser
    ~short_name:'T'
    ~long_name:"no-typecheck"
    disable_typechecking_option;
  let spare_args = BatOptParse.OptParser.parse_argv parser in
  match spare_args with
  | [] ->
    { toploop_typechecker_disabled =
        Option.default false @@
        disable_typechecking_option.BatOptParse.Opt.option_get()
    }
  | _ -> failwith "BAD!" (* TODO: better error message *)
;;

let () =
  (* parse command-line arguments *)
  let toploop_options = command_line_parsing () in

  print_string "TinyBang 0.3 Toploop\n";
  print_string "--------------------\n";
  print_string "\n";
  print_string "Please enter an expression to evaluate followed by \";;\".\n";
  print_string "\n";
  flush stdout;
  Tiny_bang_parser.parse_tiny_bang_expressions IO.stdin
  |> LazyList.map fst
  |> LazyList.iter (toploop_operate toploop_options)
;;
#+END_EXAMPLE
***** TODO Consider extracting it to the abstract toploop as well
**** TODO Figure out what the ~Tiny_bang_parser_support.get_ast_position_hash ()~ thing is all about
     It's present on Little Bang parser, but I didn't use in Big Bang parser
     because it was ignored by the Little Bang toploop and didn't immediately
     understand what it was supposed to mean.

     For more information:

     1. [[https://github.com/JHU-PL-Lab/big-bang/blob/850edbd6ec00a8ea7c60fb1469fd471502681aba/src/little-bang-parser/little_bang_parser.ml#L19][This]] is where the data is generated.
     2. [[https://github.com/JHU-PL-Lab/big-bang/blob/850edbd6ec00a8ea7c60fb1469fd471502681aba/src/little-bang-toploop/little_bang_toploop.ml#L43][And this]] is where the data gets ignored.
***** TODO Maybe reintroduce it in the Big Bang parser
**** TODO Remove the =_generated= part of lexers and parsers names
*** TODO Abstract version number
    Toploops need the version number and it's repeated all over, instead of
    having a single source.
*** TODO Remove repetitions on Big Bang to Little Bang translator generated code
    Some parts of the Little Bang code generated by the Big Bang to Little Bang
    translator are repeated several times. For example, function abstractions
    (a.k.a. named functions) allow recursion by using the Y Combinator for
    self-referentiality. The Y Combinator itself never changes, but still, it's
    being copied along with every function abstraction and not being reused.

    The proposed solution is to add a preamble to the generated Little Bang code
    with all the useful helpers.

    Ideally, there should be an easy way for the translation functions in
    =big_bang_translator.ml= to declare that they require some helper function
    to be available on the generated Little Bang code. Also, ideally, only the
    helpers required by the particular Little Bang program being generated
    should be present on the preamble.
**** TODO Find out what are the helpers that could be extracted to the preamble
**** TODO Architect an mechanism for translation functions to declare the need for helper functions
**** TODO Architect an mechanism for declaring helper functions
**** TODO Add the preamble to the generated Little Bang code
** TODO Add to Little Bang things that Tiny Bang already supports
*** TODO Ref cells
*** TODO Built-ins
**** TODO =int+=
**** TODO =int==
** TODO Add missing things to Tiny Bang
*** TODO =int-=
*** TODO =int*=
*** TODO =int/=
*** TODO =char=
*** TODO =char==
** TODO Add to Little Bang the things recently added to Tiny Bang on the previous bullet
** TODO Finish up the Big Bang translation layer
*** TODO Assignment
**** TODO Mutable assignments and updates
**** TODO Variables referring to ref cells, when used, are automatically deferred (i.e. no need for a =!= as in OCaml)
**** TODO =object.field = value= works by projecting out a ref cell, which is then updated
*** TODO Built-ins
**** They work by overloaded functions (onions of functions)
#+BEGIN_EXAMPLE
int=
int+

⊕ x y z ...

e1 =? e2

equal? (`1 (e1) & `2 (e2))

equal? =
    (fun `1 x:int * `2 y:int -> int= x y)
  & (fun `1 x:char * `2 y:char -> char= x y)


g = fun p1 \ { p1 = `A p2, p2 = () } -> ...
f = fun p0 \ { p0 = x : int } -> { r = x }
a = 1
b = 'z'
c = a & b
z = f c
#+END_EXAMPLE
**** TODO Number
***** TODO Literal
***** TODO Operations
**** TODO Characters
***** TODO Literals
***** TODO Operations
**** TODO Text
***** TODO It's translated as a list of characters
**** TODO Equality operations
*** TODO Patterns
**** TODO Empty onion is the only kind of primitive literal that we're going to make work on the first moment
**** TODO The =number= keyword matches any number and the =character= keyword matches any character
* Medium-term
** Missing translations
*** List pattern rest
**** =[*rest]= has a known bug, refer to =FIXME:= comment in =big_bang_translation.ml=
*** Object =private= sections
** Keywords for literals
#+BEGIN_EXAMPLE
mutable dictionary {}
#+END_EXAMPLE
*** User defined
#+BEGIN_EXAMPLE
red_black_tree_set {}
#+END_EXAMPLE
** Literals
*** Arrays
#+BEGIN_EXAMPLE
let y = array [1,2,3]
y(2)
y(2) = 5

let y = object
     private
         let my_data = «« makeArray 1 2 3 »»
     public
         def get(i) =
             «« readArray my_data i »»
         end
         def set(i,x) =
             «« writeArray my_data i x »»
         end
end

y.set(2,5)

let z = array of 5 0
z(4)
z(4) = 1
#+END_EXAMPLE
*** Sets
*** Maps
** Functions
*** Translate ~return~ statement
** Primitive literals in patterns
*** Patterns such as =5= would be encoded as =as int and y where y =? 5= and we don't have =where= guards in patterns
* Long-term
** Unicode
** Add pattern disjunction concrete syntax
#+BEGIN_EXAMPLE
p0 \ { p0 = p1 | p2; p1 = int; p2 = char }
     IMPLICIT BINDING: binds p0 only
     EXPLICIT BINDING: binds nothing

p0 \ { p0 = p1 * p2; p1 = x; x = (); p2 = int }
int * x
     IMPLICIT BINDING: binds p0, p1, p2, x
p0 \ { p0 = p1 * p2; p1 = bind x; p2 = int }
     EXPLICIT BINDING: binds x

p0 \ { p0 = p1 | p2; p1 = p3 * p4; p3 = int; p4 = bind x;
        p2 = p5 * p6; p5 = char; p6 = bind x }
     EXPLICIT BINDING: binds x (because it's bound in both disjuncts)

p0 \ { p0 = p1 | p2; p1 = `Nil p3; p3 = (); p2 = p4 * p5; p4 = `Tl p0;
        p5 = `Hd p6; p6 = p7 * p8; p7 = int; p8 = bind x }
µπ. `Hd (int * x) * `Tl π
#+END_EXAMPLE
** Exceptions
** Regex
