#+TITLE: Roadmap

* Short term
** TODO Refactorings
*** TODO [[https://github.com/JHU-PL-Lab/big-bang/issues/1][Abstract over toploops]]
**** Base the abstraction on Big Bang lexer, parser and toploop
**** TODO Figure out what the ~Tiny_bang_parser_support.get_ast_position_hash ()~ thing is all about
     It's present on Little Bang parser, but I didn't use in Big Bang parser
     because it was ignored by the Little Bang toploop and didn't immediately
     understand what it was supposed to mean.

     For more information:

     1. [[https://github.com/JHU-PL-Lab/big-bang/blob/850edbd6ec00a8ea7c60fb1469fd471502681aba/src/little-bang-parser/little_bang_parser.ml#L19][This]] is where the data is generated.
     2. [[https://github.com/JHU-PL-Lab/big-bang/blob/850edbd6ec00a8ea7c60fb1469fd471502681aba/src/little-bang-toploop/little_bang_toploop.ml#L43][And this]] is where the data gets ignored.
***** TODO Maybe reintroduce it in the Big Bang parser
**** TODO Remove the =_generated= part of lexers and parsers names
*** TODO Remove repetitions on Big Bang to Little Bang translator generated code
    Some parts of the Little Bang code generated by the Big Bang to Little Bang
    translator are repeated several times. For example, function abstractions
    (a.k.a. named functions) allow recursion by using the Y Combinator for
    self-referentiality. The Y Combinator itself never changes, but still, it's
    being copied along with every function abstraction and not being reused.

    The proposed solution is to add a preamble to the generated Little Bang code
    with all the useful helpers.

    Ideally, there should be an easy way for the translation functions in
    =big_bang_translator.ml= to declare that they require some helper function
    to be available on the generated Little Bang code. Also, ideally, only the
    helpers required by the particular Little Bang program being generated
    should be present on the preamble.
**** TODO Find out what are the helpers that could be extracted to the preamble
**** TODO Architect an mechanism for translation functions to declare the need for helper functions
**** TODO Architect an mechanism for declaring helper functions
**** TODO Add the preamble to the generated Little Bang code
** TODO Add to Little Bang things that Tiny Bang already supports
*** TODO Ref cells
*** TODO Built-ins
**** TODO =int+=
**** TODO =int==
** TODO Add missing things to Tiny Bang
*** TODO =int-=
*** TODO =int*=
*** TODO =int/=
*** TODO =char=
*** TODO =char==
** TODO Add to Little Bang the things recently added to Tiny Bang on the previous bullet
** TODO Finish up the Big Bang translation layer
*** TODO Assignment
**** TODO Mutable assignments and updates
**** TODO Variables referring to ref cells, when used, are automatically deferred (i.e. no need for a =!= as in OCaml)
**** TODO =object.field = value= works by projecting out a ref cell, which is then updated
*** TODO Built-ins
**** They work by overloaded functions (onions of functions)
#+BEGIN_EXAMPLE
int=
int+

⊕ x y z ...

e1 =? e2

equal? (`1 (e1) & `2 (e2))

equal? =
    (fun `1 x:int * `2 y:int -> int= x y)
  & (fun `1 x:char * `2 y:char -> char= x y)


g = fun p1 \ { p1 = `A p2, p2 = () } -> ...
f = fun p0 \ { p0 = x : int } -> { r = x }
a = 1
b = 'z'
c = a & b
z = f c
#+END_EXAMPLE
**** TODO Number
***** TODO Literal
***** TODO Operations
**** TODO Characters
***** TODO Literals
***** TODO Operations
**** TODO Text
***** TODO It's translated as a list of characters
**** TODO Equality operations
*** TODO Patterns
**** TODO Empty onion is the only kind of primitive literal that we're going to make work on the first moment
**** TODO The =number= keyword matches any number and the =character= keyword matches any character
* Medium-term
** Missing translations
*** List pattern rest
**** =[*rest]= has a known bug, refer to =FIXME:= comment in =big_bang_translation.ml=
*** Object =private= sections
** Keywords for literals
#+BEGIN_EXAMPLE
mutable dictionary {}
#+END_EXAMPLE
*** User defined
#+BEGIN_EXAMPLE
red_black_tree_set {}
#+END_EXAMPLE
** Literals
*** Arrays
#+BEGIN_EXAMPLE
let y = array [1,2,3]
y(2)
y(2) = 5

let y = object
     private
         let my_data = «« makeArray 1 2 3 »»
     public
         def get(i) =
             «« readArray my_data i »»
         end
         def set(i,x) =
             «« writeArray my_data i x »»
         end
end

y.set(2,5)

let z = array of 5 0
z(4)
z(4) = 1
#+END_EXAMPLE
*** Sets
*** Maps
** Functions
*** Translate ~return~ statement
** Primitive literals in patterns
*** Patterns such as =5= would be encoded as =as int and y where y =? 5= and we don't have =where= guards in patterns
* Long-term
** Unicode
** Add pattern disjunction concrete syntax
#+BEGIN_EXAMPLE
p0 \ { p0 = p1 | p2; p1 = int; p2 = char }
     IMPLICIT BINDING: binds p0 only
     EXPLICIT BINDING: binds nothing

p0 \ { p0 = p1 * p2; p1 = x; x = (); p2 = int }
int * x
     IMPLICIT BINDING: binds p0, p1, p2, x
p0 \ { p0 = p1 * p2; p1 = bind x; p2 = int }
     EXPLICIT BINDING: binds x

p0 \ { p0 = p1 | p2; p1 = p3 * p4; p3 = int; p4 = bind x;
        p2 = p5 * p6; p5 = char; p6 = bind x }
     EXPLICIT BINDING: binds x (because it's bound in both disjuncts)

p0 \ { p0 = p1 | p2; p1 = `Nil p3; p3 = (); p2 = p4 * p5; p4 = `Tl p0;
        p5 = `Hd p6; p6 = p7 * p8; p7 = int; p8 = bind x }
µπ. `Hd (int * x) * `Tl π
#+END_EXAMPLE
** Exceptions
** Regex
