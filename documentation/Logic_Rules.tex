\documentclass{article}

\usepackage{BigBang}
\usepackage{mathpartir}
\usepackage{cancel}

\begin{document}

\section*{Language Grammar}

\begin{eqnarray*}
    e               &::=&       v
                           \gOr x
                           \gOr e\ e
                           \gOr \gtBt x\ e
                           \gOr e \gtAmp e
                           \gOr \gtCase e \gtOf \texttt{\char`\{} B \texttt{\char`\}}
%                           \gOr \gtDef x \gtEq e \gtIn e
%                           \gOr x \gtEq e \gtIn e
\\
    x               &::=&       [\texttt{a-zA-Z0-9\char`\_}]^+
\\
    v               &::=&       [\texttt{0-9}]^+
                           \gOr \texttt{'}[\texttt{\char`\^\char`\\}]\texttt{'}
                           \gOr \texttt{'\char`\\\char`\\'}
                           \gOr \texttt{()}
                           \gOr \gtFun x\texttt{ -> }e
\\
    B               &::=&       b
                           \gOr b\texttt{\char`\; }B
\\
    b               &::=&       \chi\texttt{ -> }e
                           \gOr x\texttt{:}\chi\texttt{ -> }e
\\
    \chi            &::=&       \tprim
                           \gOr \gtFun
                           \gOr \gtBt x\ x
                           \gOr \texttt{\char`\_}
\end{eqnarray*}


\section*{Type System Grammar}

\begin{eqnarray*}
%     \anyAlpha       &::=&       \alpha
%                            \gOr \alphaUp
% \\
    \alpha          &::=&       \alphaOpen
                           \gOr \alphaClosed
\\
    \tauUpOpen      &::=&       \tprim
                           \gOr \gtTop
                           \gOr \alphaUp \fto \alpha
                           \gOr \alphaUp
                           \gOr \alphaOpen
\\
    \tauUpClosed    &::=&       \tauUpOpen
                           \gOr \alpha
\\
    \tauDownOpen    &::=&       \tprim
                           \gOr \gtTop
                           \gOr \lbl \tauDownOpen
                           \gOr \tauDownOpen \gtAmp \tauDownOpen
                           \gOr \forall \alphaList. \alpha \fto \alpha \cSeparator \constraintList
                           \gOr \alphaOpen
%                           \gOr \cellDown{\anyAlpha}
\\
    \tauDownClosed  &::=&       \tprim
                           \gOr \gtTop
                           \gOr \lbl \tauDownClosed
                           \gOr \tauDownClosed \gtAmp \tauDownClosed
                           \gOr \forall \alphaList. \alpha \fto \alpha \cSeparator \constraintList
                           \gOr \alpha
\\
    \tauChi         &::=&       \tprim
                           \gOr \gtTop
                           \gOr \lbl \alphaClosed
                           \gOr \gtFun
\\
    \tprim          &::=&       \gtInt
                           \gOr \gtChar
                           \gOr \gtUnit
\\
    \lbl            &::=&       \gtBt [\texttt{a-zA-Z0-9}]^+
\\
    \subtype        &::=&       \tauDownClosed <: \tauUpClosed
\\
    \constraint     &::=&       \subtype
                           \gOr \gtCase \alphaUp \gtOf \guard^*
                           \gOr \equatable{\alpha}{\alpha}
                           \gOr \gtBottom
\\
    \guard          &::=&       \tauChi \fto \constraint
\\
    \constraintList &::=&       \constraint^*
\end{eqnarray*}

\section*{Type Inference Rules}

\begin{mathpar}
    \bbrule{Hypothesis}{
        x:\alphaClosed \in \context
    }{
        \typeRel{\context}{x}{\alphaClosed}{\emptyset}
    }
    
    \bbrule{Label}{
        \typeRel{\context}{e}{\tauDownClosed}{\C}
    }{
        \typeRel{\context}{\lbl e}{\lbl \alphaClosed}{\{\tauDownClosed <: \alphaClosed\} \cup \C}
    }
    
    \bbrule{Onion}{
        \typeRel{\context}{e_1}{\tauDownClosed_1}{\C_1} \\
        \typeRel{\context}{e_2}{\tauDownClosed_2}{\C_2}
    }{
        \typeRel{\context}{e_1 \gtAmp e_2}{\alphaClosed_1 \gtAmp \alphaClosed_2}{\{\tauDownClosed_1 <: \alphaClosed_1, \tauDownClosed_2 <: \alphaClosed_2\} \cup \C_1 \cup \C_2}
    }
    
    \bbrule{Function}{
        \typeRel{\context,x:\alphaClosed_2}{e}{\tauDownClosed}{\C}
    }{
        \typeRel{\context}{\lambda x.\ e}{\alphaClosed_1}{
            \{(\forall \alphaList. \alphaClosed_2 \fto \alphaOpen_3 \cSeparator \{\tauDownClosed <: \alphaOpen_3\} \cup \C) <: \alphaClosed_1\}}
    }
    
    \bbrule{Application}{
        \typeRel{\context}{e}{\tauDownClosed_1}{\C_1} \\
        \typeRel{\context}{e'}{\tauDownClosed_2}{\C_2}
    }{
        \typeRel{\context}{e\ e'}{\alphaClosed}{\{\tauDownClosed_1 <: \alphaUp \fto \alphaClosed, \tauDownClosed_2 <: \alphaUp\} \cup \C_1 \cup \C_2}
    }
    
    \bbrule{Case}{
        \typeRel{\context}{e}{\tauDownClosed}{\C} \\
        \overline{\gamma_n,\tauChi_n = \kappa(\chi_n)} \\
        \overline{\typeRel{\context,\gamma_n}{e_n}{\tauDownClosed_n}{\C_n}}
    }{
        \typeRel{\context}{\gtCase e \gtOf \overline{\chi_n \fto e_n}}{\alphaClosed}{\C \cup \{\tauDownClosed <: \alphaUp,
            \gtCase \alphaUp \gtOf \overline{\tauChi_n \fto (\C_n \cup \{\tauDownClosed_n <: \alphaClosed\})}\}}
    }
    
    \bbrule{Equality}{
        \typeRel{\context}{e_1}{\tauDownClosed_1}{\C_1} \\
        \typeRel{\context}{e_2}{\tauDownClosed_2}{\C_2}
    }{
        \typeRel{\context}{e_1 \gtBEq e_2}{\alphaClosed_0}%
                {\{%
                    \texttt{\char`\`True ()} <: \alphaClosed_0,%
                    \texttt{\char`\`False ()} <: \alphaClosed_0,%
                    \tauDownClosed_1 <: \alphaClosed_1,
                    \tauDownClosed_2 <: \alphaClosed_2,
                    \equatable{\alphaClosed_1}{\alphaClosed_2}
                 \} \cup \C_1 \cup \C_2}
    }
\end{mathpar}

\subsection*{$\kappa$ Definition}

$$
\kappa(\chi) =
    \begin{cases}
        (\{x:\alphaClosed\}, \lbl \alphaClosed)     &, \chi = \lbl x \\
        (\emptyset, \tprim)                         &, \chi = \tprim \\
        (\emptyset, \gtFun)                         &, \chi = \gtFun \\
        (\emptyset, \gtTop)                         &, \chi = \texttt{\char`\_}
    \end{cases}
$$

\section*{Constraint Closure Rules}

\subsection*{General Constraint Closure Rules}

\begin{mathpar}
    \bbrule{Transitivity}{
        \tauDownOpen <: \alphaClosed \\
        \alphaClosed <: \tauUpClosed
    }{
        \tauDownOpen <: \tauUpClosed
    }
    
    \bbrule{Label Construction}{
        \tauDownOpen <: \alphaClosed \\
        \lbl \alphaClosed <: \tauUpClosed
    }{
        \lbl \tauDownOpen <: \tauUpClosed
    }
    
    \bbrule{Onion Construction}{
        \tauDownOpen_1 <: \alphaClosed_1 \\
        \tauDownOpen_2 <: \alphaClosed_2 \\
        \alphaClosed_1 \gtAmp \alphaClosed_2 <: \tauUpClosed
    }{
        \tauDownOpen_1 \gtAmp \tauDownOpen_2 <: \tauUpClosed
    }
    
    \bbrule{Case Analysis}{
        \tauDownOpen <: \alphaUp \\
        \gtCase \alphaUp \gtOf \ldots \vert \tauChi_i \fto \C_i \vert \ldots \\
        \tauDownOpen \immCompat \tauChi_i \icSeparator \tauDownOpen' \\
        \forall j<i. \tauDownOpen \cancel{\immCompat} \tauChi_j
    }{
        \C_i \cup \mu(\tauDownOpen', \tauChi_i)
    }
    
    \bbrule{Application}{
        \tauDownOpen <: \alphaUp \\
        (\forall \alphaList. \alphaClosed_1 \fto \alphaOpen_2 \cSeparator \C) <: \alphaUp \fto \alphaClosed_3
    }{
        \varphi(\alphaList, \C \cup \{\tauDownOpen <: \alphaClosed_1, \alphaOpen_2 <: \alphaClosed_3\}, \alphaUp)
    }
\end{mathpar}

\subsection*{$\mu$ Definition}

$$
\mu(\tauDownOpen, \tauChi) =
    \begin{cases}
        \{ \tauDownOpen' <: \alphaClosed \}             &, \tauDownOpen = \lbl \tauDownOpen', \tauChi = \lbl \alphaClosed \\
        \emptyset                                       &, \text{otherwise}
    \end{cases}
$$

\subsection*{$\varphi$ Definition}

$$
\varphi(\alphaList, \C, \alphaUp) = \{ \constraint : \constraint' \in \C, \varphi(\alphaList, \constraint', \alphaUp) = \constraint \}
$$

(TODO) % TODO: how best to describe the deep replacement?

\subsection*{Contradiction Rules}

\begin{mathpar}
    \bbrule{Case Contradiction}{
        \tauDownOpen <: \alphaUp \\
        \gtCase \alphaUp \gtOf \ldots \vert \tauChi_i \fto \C_i \vert \ldots \\
        \forall i. \tauDownOpen \cancel{\immCompat} \tauChi_i
    }{ \gtBottom }
    
    \bbrule{Mismatched Primitives}{
        \tprim <: \tprim' \\
        \tprim \neq \tprim'
    }{ \gtBottom }
    
    \bbrule{L-P Subtype}{
        \lbl \tauDownOpen <: \tprim
    }{ \gtBottom }
    
    \bbrule{P-F Subtype}{
        \tprim <: \alphaUp \fto \alphaClosed
    }{ \gtBottom }
    
    \bbrule{F-P Subtype}{
        (\forall \alphaList. \alphaClosed_1 \fto \alphaOpen_2 \cSeparator \C) <: \tprim
    }{ \gtBottom }
    
    \bbrule{L-F Subtype}{
        \lbl \tauDownOpen <: \alphaUp \fto \alphaClosed
    }{ \gtBottom }
    
    \bbrule{Equality}{
        \equatable{\alphaClosed_1}{\alphaClosed_2} \\
        \tauDownOpen_1 <: \alphaClosed_1 \\
        \tauDownOpen_2 <: \alphaClosed_2 \\
        \neg \concreteEquatable{\tauDownOpen_1}{\tauDownOpen_2}
    }{ \gtBottom }
\end{mathpar}

\subsection*{Immediate Compatibility Rules}

{\footnotesize This relation is typed $\tauDownOpen \immCompat \tauChi \icSeparator \tauDownOpen$ and is read as ``$\tauDownOpen$ is immediately compatible with $\tauChi$ as $\tauDownOpen'$''.  The abbreviation $\tauDownOpen \cancel{\immCompat} \tauChi$ is used to designate $\forall \tauDownOpen' . \tauDownOpen \cancel{\immCompat} \tauChi \icSeparator \tauDownOpen'$.}

\begin{mathpar}
    \bbrule{Top Compatibility}{ }{\tauDownOpen \immCompat \gtTop \icSeparator \gtTop}
    
    \bbrule{Primitive Compatibility}{ }{\tprim \immCompat \tprim \icSeparator \tprim}
    
    \bbrule{Label Compatibility}{ }{\lbl \tauDownOpen \immCompat \lbl \alphaClosed \icSeparator \lbl \tauDownOpen}
    
    \bbrule{Function Compatibility}{ }{\forall \alphaList. \alpha \fto \alpha' \cSeparator \C \immCompat \gtFun \icSeparator \forall \alphaList. \alpha \fto \alpha' \cSeparator \C}
    
    \bbrule{Onion Left Compatibility}{
        \tauDownOpen_1 \immCompat \tauChi \icSeparator \tauDownOpen'
    }{
        \tauDownOpen_1 \gtAmp \tauDownOpen_2 \immCompat \tauChi \icSeparator \tauDownOpen'
    }
    
    \bbrule{Onion Right Compatibility}{
        \tauDownOpen_1 \cancel{\immCompat} \tauChi \\
        \tauDownOpen_2 \immCompat \tauChi \icSeparator \tauDownOpen'
    }{
        \tauDownOpen_1 \gtAmp \tauDownOpen_2 \immCompat \tauChi \icSeparator \tauDownOpen'
    }
    
    \bbrule{Promise Compatibility}{
        \tauDownOpen <: \alphaOpen \\
        \tauDownOpen \immCompat \tauChi \icSeparator \tauDownOpen'
    }{
        \alphaOpen \immCompat \tauChi \icSeparator \tauDownOpen'
    }
\end{mathpar}

\subsection*{Concrete Equatability}

$$
\flatten{\tauDownOpen} =
    \begin{cases}
        \textrm{the concatenation of }\flatten{\tauDownOpen_1}\textrm{ and }\flatten{\tauDownOpen_2} & \textrm{if }\tauDownOpen = \tauDownOpen_1 \gtAmp \tauDownOpen_2 \\
        [\tauDownOpen] & \textrm{otherwise}
    \end{cases}
$$

\begin{mathpar}

    \bbrule{Primitive Equatability}{ }{\concreteEquatable{\tprim}{\tprim}}
    
    \bbrule{Label Equatability}{
        \concreteEquatable{\tauDownOpen_1}{\tauDownOpen_2}
    }{
        \concreteEquatable{\lbl \tauDownOpen_1}{\lbl \tauDownOpen_2}
    }
    
    \bbrule{Onion Equatability}{
        \flatten{\tauDownOpen_1 \gtAmp \tauDownOpen_2} = [\tauDownOpen_{1,1},\ldots,\tauDownOpen_{1,n}] \\
        \flatten{\tauDownOpen'_1 \gtAmp \tauDownOpen'_2} = [\tauDownOpen_{2,1},\ldots,\tauDownOpen_{2,m}] \\
        \forall i \in \{1..n\} \exists j \in \{1..m\}. \concreteEquatable{\tauDownOpen_i}{\tauDownOpen_j'} \\
        \forall j \in \{1..m\} \exists i \in \{1..n\}. \concreteEquatable{\tauDownOpen_i}{\tauDownOpen_j'}
    }{
        \concreteEquatable{\tauDownOpen_1 \gtAmp \tauDownOpen_2}{\tauDownOpen'_1 \gtAmp \tauDownOpen'_2}
    }
    
    \bbrule{Promise Equatability Left}{
        \forall \tauDownOpen' <: \alphaOpen. \concreteEquatable{\tauDownOpen'}{\tauDownOpen}
    }{
        \concreteEquatable{\alphaOpen}{\tauDownOpen}
    }
    
    \bbrule{Promise Equatability Right}{
        \tauDownOpen\textrm{ not of the form }\alphaOpen' \\
        \forall \tauDownOpen' <: \alphaOpen. \concreteEquatable{\tauDownOpen}{\tauDownOpen'}
    }{
        \concreteEquatable{\tauDownOpen}{\alphaOpen}
    }
\end{mathpar}

\end{document}
