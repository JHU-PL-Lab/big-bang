#+TITLE: Big Bang User Documentation
#+AUTHOR: Johns Hopkins University Programming Languages Laboratory

* Phylosophy
** Target user
   Seasoned scripter (someone familiar with Python).
* Features
** Literals
*** Primitive data
**** Booleans
***** True
#+BEGIN_SRC big-bang
true
#+END_SRC
***** False
#+BEGIN_SRC big-bang
false
#+END_SRC
**** Numbers
***** Integers (~int~)
#+BEGIN_SRC big-bang
32
-10
#+END_SRC
**** Characters
#+BEGIN_SRC big-bang
'a'
#+END_SRC
**** Texts
#+BEGIN_SRC big-bang
"Hello, Big Bang."
#+END_SRC
*** Structured data
**** Onions
#+BEGIN_SRC big-bang
3 & 'a'
#+END_SRC
**** Records
#+BEGIN_SRC big-bang
{ a = 2, b = 3 }
#+END_SRC
**** Lists
#+BEGIN_SRC big-bang
[2, "Lists are heterogeneous!", 'a']
#+END_SRC
**** Labels
#+BEGIN_SRC big-bang
`LanguageName "Big Bang"
#+END_SRC
** Operations
*** Primitive data types
**** Booleans
***** ~and~
***** ~or~
***** ~xor~
***** ~not~
**** Numbers
***** ~+~
***** ~-~
***** ~/~
***** ~*~
**** Texts
***** Indexing
#+BEGIN_SRC big-bang
"abc"(1) # => 'b'
#+END_SRC
*** Structured data types
**** Records
***** Selection
#+BEGIN_SRC big-bang
{ a = 2, b = 3 }.a # => 2
#+END_SRC
***** Concatenation (onioning)
#+BEGIN_SRC big-bang
{ a = 2, b = 3 } + { c = 2, d = 3 } # => { a = 2, b = 3, c = 2, d = 3 }
#+END_SRC
**** Lists
***** Indexing
#+BEGIN_SRC big-bang
[2, 3, 'a'](2) # => 'a'
#+END_SRC
*** General
**** Comparison
***** ~=?~
***** ~not=?~
** Assignments
*** Identifiers
#+BEGIN_SRC big-bang
inGrid?()
changeGrid!()
x'''''
#+END_SRC
**** Only one namespace for variables and functions (Lisp-1)
*** Immutable
#+BEGIN_SRC big-bang
let banana = "banana"
#+END_SRC
*** Mutable
**** First definition
#+BEGIN_SRC big-bang
ref coconut = "banana"
#+END_SRC
**** Update
#+BEGIN_SRC big-bang
coconut = "banana2"
#+END_SRC
**** Dereferencing is automatic (i.e. doesn't require ~!~)
#+BEGIN_SRC big-bang
functionCall(coconut)
#+END_SRC
*** Shadowing
**** Not allowed (except with function parameters)
** Flow control constructs
*** Conditionals
#+BEGIN_SRC big-bang
if <condition>
  <expression>
else if <condition>
  <expression>
else
  <expression>
end
#+END_SRC
*** Pattern matches
#+BEGIN_SRC big-bang
match <expression>
as <pattern> in <expression>
as <pattern> in <expression>
end
#+END_SRC
*** Loops
#+BEGIN_SRC big-bang
repeat while <condition>
  <expression>
end
#+END_SRC
** Functions
*** Definition
**** Named
#+BEGIN_SRC big-bang
fun <name>(<parameter-list>) =
  <expression>
end
#+END_SRC
**** Anonymous
#+BEGIN_SRC big-bang
fun (<parameter-list>) =
  <expression>
end
#+END_SRC
**** No difference between non-recursive and recursive functions
*** Application
#+BEGIN_SRC big-bang
identity(3)
#+END_SRC
** Object orientation
*** Objects
#+BEGIN_SRC big-bang
object
  include
    SomeOtherObject
  public
    x = 0
    y = 0

    # `self` is optional
    fun magnitude() = sqrt(self.x * self.x + y * y) end
end
#+END_SRC
** Standard library
*** Characters
**** ~ord('a')~
**** ~chr(64)~
*** I/O
**** Read one char
**** Print one char
** Documentation
*** Comments
**** ~#~
** Code style
*** Indentation is 2 spaces
*** Trailing commas
**** Structured data literals
*** Identifiers
**** CamelCase
*** ~;~, ~then~ and ~do~ work as new line separators
** Anti-features (i.e. features we are not going to have soon)
*** Exceptions
*** Regex
* Grammar
#+BEGIN_SRC ebnf
literal =
  | primitive-literal
  | composite-literal

primitive-literal =
  | boolean-literal
  | int-literal
  | character-literal
  | text-literal
  | empty-onion-literal

composite-literal =
  | record-literal
  | list-literal
  | label-literal

boolean-literal =
 | "true"
 | "false"

int-literal =
  | "-"? ["1"-"9"] ["0"-"9"]*
  | "-"? "0"

character-literal = ...

text-literal = ...

empty-onion-literal = "()"

record-literal = "{" list-of(field = record-field, separator = ",") "}"

record-field = identifier "=" expression

list-literal = "[" list-of(field = list-field, separator = ",") "]"

list-field =
  | expression

label-literal = label-identifier expression

label-identifier = "`" identifier-continued+

onion-literal = ...

expression =
  | assignment-expression
  | immutable-definition-expression
  | mutable-definition-expression
  | conditional-expression
  | repeat-expression
  | sequence-expression
  | function-expression
  | object-expression
  | application-expression
  | comparison-expression

sequence-expression = expression divider expression

list-of(
  field,
  separator,
  possibly-empty? = true,
  possibly-trailing-separator? = true
) = ...

identifier = identifier-start identifier-continued* identifier-end?

identifier-start = ["A"-"Z" "a"-"z" "_"]

identifier-continued =
  | ["A"-"Z" "a"-"z" "_" "0"-"9"]

identifier-end =
  | ["?" "!"]
  | "'"+

comment = "#" .*? $

immutable-definition-expression = "let" assignment-expression

mutable-definition-expression = "ref" assignment-expression

assignment-expression = identifier "=" expression

conditional-expression =
  | if-expression
  | match-expression

if-expression =
  "if" expression divider expression ("else" expression ("else" "if" expression)*)? "end"

new-line = ["\n" "\r" "\r\n"]

divider =
  | ["then" "do" ";"]
  | new-line

match-expression =
  "match" expression ("as" pattern "in" expression)+ "end"

repeat-expression =
  "repeat" (
    | while-expression
  )

while-expression =
  "while" expression divider expression "end"

function-expression =
  | named-function-expression
  | anonymous-function-expression

named-function-expression = "fun" identifier formal-parameters "=" expression "end"

anonymous-function-expression = "fun" formal-parameters "=" expression "end"

formal-parameters = "(" list-of(field = formal-parameter, separator = ",") ")"

formal-parameter =
  | identifier

application-expression =
  | identifier actual-parameters

actual-parameters = "(" list-of(field = actual-parameter, separator = ",") ")"

actual-parameter =
  | expression

object-expression = "object" object-section* "end"

object-section = object-section-header object-section-body

object-section-header = ["public" "include"]

object-section-body = object-member+

object-member =
  | assignment-expression
  | method-expression

method-expression =
  | "def" identifier formal-parameters "=" expression "end"

comparison-expression =
  | expression "=?" expression
  | expression "not=?" expression
#+END_SRC
