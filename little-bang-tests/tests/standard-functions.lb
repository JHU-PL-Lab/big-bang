# EXPECT-MATCHES: ()

# TODO: turn typechecking off to avoid performance delay while necessary.

# TODO: try to implement :: as a pattern to eliminate use of 
# `Head head & `Tl tail in fun arg patterns. Then, also replace `Nil () by [].

# TODO: carriage return after open parenthesis in function call 
# (e.g. application via arg list) has caused an error. Capture so it can be tested.

# TODO: function passing by name does not work directly (see divideInt comments).

# TODO: add variable name to "Undefined variable!" message.

let Common = 
  object {
    # a1: list
    # a2: list  
    append(a1, a2) = 
      let lst1 = a1 in
      let lst2 = a2 in
      let f = 
        ((fun lst1:(`Hd head & `Tl tail), lst2 -> 
            head :: (self.append(a1=tail, a2=lst2))) &
         (fun lst1:(`Nil ()), lst2 -> lst2))
      in f(lst1=a1, lst2=a2)

    #TODO: convert into LittleBang unary operator "not"
    # a1: boolean
    negate(a1) =
      let f = 
        ((fun arg1:(`True ())  -> `False ()) &
         (fun arg1:(`False ()) -> `True ()))
      in f(arg1=a1)

    #TODO: convert into LittleBang binary operator "and"
    # a1: boolean
    # a2: boolean
    areBothTrue(a1, a2) =
      let f = 
        ((fun arg1:(`True ()), arg2  -> if arg2 then `True () else `False ()) &
         (fun arg1:(`False ()), arg2 -> `False ()))
      in f(arg1=a1, arg2=a2)

    #TODO: convert into LittleBang binary operator "or"
    # a1: boolean
    # a2: boolean
    isOneTrue(a1, a2) =
      let f = 
        ((fun arg1:(`True ()), arg2  -> `True ()) &
         (fun arg1:(`False ()), arg2 -> arg2))
      in f(arg1=a1, arg2=a2)

    #TODO: convert into LittleBang binary operator "<"
    isLessThan(a1:int, a2:int) =
      let b1 = (a1 >= a2) in
      if self.negate(a1=b1) then `True ()
      else `False ()

    #TODO: convert into LittleBang binary operator ">"
    isGreaterThan(a1:int, a2:int) =
      let b1 = (a1 <= a2) in
      if self.negate(a1=b1) then `True ()
      else `False ()

    #TODO: replace explicit reference to self.divideIntHelper with func if possible.
    # Helper for int multiplication and division.
    # a1: helper function
    # a2: param 1
    # a3: param 2
    multDivIntHelper(a1, a2:int, a3:int) =
      let func = a1 in
      let param1 = a2 in
      let param2 = a3 in
      if param1 == 0 then 0
      else
        let bothPos = self.areBothTrue(a1=self.isLessThan(a1=0, a2=param1),
                                       a2=self.isLessThan(a1=0, a2=param2)) in
        let bothNeg = self.areBothTrue(a1=self.isGreaterThan(a1=0, a2=param1),
                                       a2=self.isGreaterThan(a1=0, a2=param2)) in
        if self.isOneTrue(a1=bothPos, a2=bothNeg) then
          if self.isLessThan(a1=0, a2=param1) then
            self.divideIntHelper(a1=0, a2=param1, a3=param2)
          else
            self.divideIntHelper(a1=0, a2=0 - param1, a3=0 - param2)
        else
          if self.isGreaterThan(a1=0, a2=param1) then
            0 - self.divideIntHelper(a1=0, a2=0 - param1, a3=param2)
          else
            0 - self.divideIntHelper(a1=0, a2=param1, a3=0 - param2)

    divideIntHelper(a1:int, a2:int, a3:int) =
      let count = a1 in
      let subtraction = a2 in
      let subtractor = a3 in
      if self.isLessThan(a1=subtraction, a2=subtractor) then
        count
      else
        self.divideIntHelper(
                             a1=(count + 1), 
                             a2=(subtraction - subtractor), 
                             a3=subtractor)

    #TODO: replace () with self.divideIntHelper if possible.
    #TODO: convert into LittleBang binary operator "/"
    # This goes into an infinite loop when division is by zero.
    divideInt(a1:int, a2:int) =
      let param1 = a1 in
      let param2 = a2 in
      self.multDivIntHelper(a1=(), a2=param1, a3=param2)
    
    #TODO: other common binary operators that could be implemented: "*", "%"  

  } in 


let LinkedList =
  object {
    # a1: list
    # returns the length of the list.
    getLength(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> 1 + (self.getLength(a1=tail))) &
         (fun arg1:(`Nil ()) -> 0))
      in f(arg1=a1)

    # a1: list
    # returns the head of the list, or a failure message if the list is empty.
    getHead(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> head) &
         (fun arg1:(`Nil ()) -> `Failure ()))
      in f(arg1=a1)

    # a1: list
    # returns the tail of the list, or a failure message if the list is empty.
    getTail(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> tail) &
         (fun arg1:(`Nil ()) -> `Failure ()))
      in f(arg1=a1)

    # a1: list
    # a2: index
    # returns the element in list at input index, or a failure message if not found.
    getElement(a1, a2:int) =
      let lst = a1 in
      let index = a2 in
      if Common.isLessThan(a1=index, a2=0) then `Failure ()
      else 
        let f = 
          ((fun lst:(`Hd head & `Tl tail) -> 
              if index == 0 then head
              else self.getElement(a1=tail, a2=index - 1)
           ) &
           (fun lst:(`Nil ()) -> `Failure ()))
        in f(lst=a1)

    # a1: list
    # returns a list consisting of all elements in member lists of 
    # the original list, in successive order, but now contained in 
    # the return list only.
    flatten(a1) =
      let lst = a1 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) -> Common.append(a1=head, 
                                             a2=(self.flatten(a1=tail)))) &
         (fun lst:(`Nil ()) -> lst))
      in f(lst=a1)      

    # a1: list
    # a2: fun
    # returns a new list consisting of fun applied to each element 
    # in an input list.
    map(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
           (func(a1=head)) :: (self.map(a1=tail, a2=func))) &
         (fun lst:(`Nil ()), func -> lst))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: fun
    # applies fun to each element in list, successively, and returns 
    # the result of applying fun to the last element in list.
    iterate(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            func(a1=head); self.map(a1=tail, a2=func)) &
         (fun lst:(`Nil ()), func -> ()))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: fun
    # a3: acc
    # returns the accrued value of successive applications of fun to 
    # each element in list, from left to right, each of which also 
    # takes the prior application's result, which is initially acc.
    foldLeft(a1, a2, a3:int) = 
      let lst = a1 in
      let func = a2 in
      let acc = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc -> 
            self.foldLeft(a1=tail, a2=func, a3=func(a1=head, a2=acc))) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3)

    # a1: list
    # a2: fun
    # a3: acc
    # returns the accrued value of successive applications of fun 
    # to each element in list, from right to left, each of which also 
    # takes the prior application's result, which is initially acc.
    foldRight(a1, a2, a3) = 
      let lst = a1 in
      let func = a2 in
      let acc = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc -> 
            func(a1=head, a2=self.foldRight(a1=tail, a2=func, a3=acc))) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3)

    # a1: list
    # a2: predicate
    # returns `True () if each element in list yields `True () 
    # as argument to predicate.
    isTrueForAll(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            Common.areBothTrue(a1=func(a1=head), 
                               a2=self.isTrueForAll(a1=tail, a2=func))
         ) &
         (fun lst:(`Nil ()), func -> `True ()))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: predicate
    # returns `True () if at least one element in list yields `True () 
    # as argument to predicate.
    isTrueForOne(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            if func(a1=head) then `True ()
            else self.isTrueForOne(a1=tail, a2=func)) &
         (fun lst:(`Nil ()), func -> `False ()))
      in f(lst=a1, func=a2)

    # TODO: allow this function to take elements of more types.
    # a1: list
    # a2: element (int)
    # returns `True () if element is contained in list, `False () otherwise.
    contains(a1, a2) = 
      let lst = a1 in
      let elem = a2 in
      let f = 
        (
         (fun lst:(`Hd head & `Tl tail), elem:int -> 
            if head == elem then `True ()
            else self.contains(a1=tail, a2=elem)) &

         (fun lst:(`Nil ()), elem -> `False ())
        )
      in f(lst=a1, elem=a2)

    # a1: list
    # a2: predicate
    # returns element in the list which, as argument to the predicate, 
    # yields `True (); fails if element is not found.
    find(a1, a2) =
      let f = 
        ((fun lst:(`Hd head & `Tl tail), predicate -> 
            if predicate(a1=head) then head
            else self.find(a1=tail, a2=predicate)) &
         (fun lst:(`Nil ()), predicate -> `Failure ()))
      in f(lst=a1, predicate=a2)

    # performs the action specified by func (which can be at a specific index) while being able to track current
    # index; traverses a list in foldRight fashion.
    trackIndex(a1, a2, a3, a4) = 
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc, currentIndex ->
            func(a1=head, a2=self.trackIndex(a1=tail, a2=func, a3=acc, a4=currentIndex+1), a3=currentIndex)
         ) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3, currentIndex = a4)

    # a1: list
    # a2: predicate
    filter(a1, a2) =
      let p = a2 in
      let pred = (fun a1, a2 -> if p(a1=a1) then a1 :: a2 else a2) in 
      let f =
        ((fun lst:(`Hd head & `Tl tail), predicate -> 
            self.foldRight(a1=lst, a2=predicate, a3=[])) &
         (fun lst:(`Nil ()), predicate -> `Failure ()))
      in f(lst=a1, predicate=pred)

    # a1: list
    # a2: element
    # a3: index
    # performs index validity check and calls trackIndex.
    opHelper(a1, a2, a3) =
      let lst = a1 in
      let index = a2 in
      let predicate = a3 in
      if Common.isLessThan(a1=index, a2=0) then `Failure ()
      else if self.getLength(a1=lst) <= index then `Failure ()
      else 
        let f = 
          ((fun lst:(`Hd head & `Tl tail) -> 
              self.trackIndex(a1=lst, a2=predicate, a3=[], a4=0)
           ) &
           (fun lst:(`Nil ()) -> `Failure ()))
        in f(lst=a1)

     # a1: list
     # a2: element
     # a3: index
     # returns a list with element inserted at index.
    add(a1, a2, a3) =
      let lst = a1 in
      let elem = a2 in
      let index = a3 in
      if index == 0 then elem :: lst
      else
        let predicate = (fun a1, a2, a3 -> if a3 == index then elem :: a1 :: a2 else a1 :: a2) in
        self.opHelper(a1=lst, a2=index, a3=predicate)

     # a1: list
     # a2: index
     # returns a list with element at index removed.
    remove(a1, a2) =
      let lst = a1 in
      let index = a2 in
      if index == 0 then
        let f = 
          (fun lst:(`Hd head & `Tl tail) -> 
              tail
          ) in f(lst=a1)
      else
        let predicate = (fun a1, a2, a3 -> if a3 == index then a2 else a1 :: a2) in
        self.opHelper(a1=lst, a2=index, a3=predicate)

    # This function is used by mergeSort.
    # a1: list
    # a2: list
    # a3: predicate fun
    # returns a list consisting of the merging of the two input lists, 
    # where the heads of each list are compared using predicate fun, 
    # with the element on the left argument to predicate fun being 
    # selected for merging if it yields `True (), and the element on the 
    # right being selected otherwise.
    mergeLists(a1, a2, a3) =
      let f =
        ((fun lst1:(`Nil ()), lst2:(`Nil ()), predicate -> `Nil ()
         ) &
         (fun lst1:(`Nil ()), lst2:(`Hd head & `Tl tail), predicate -> lst2
         ) &
         (fun lst1:(`Hd head & `Tl tail), lst2:(`Nil ()), predicate -> lst1
         ) &
         (fun lst1:(`Hd head1 & `Tl tail1), lst2:(`Hd head2 & `Tl tail2), predicate ->
           if predicate(a1=head1, a2=head2) then
             head1 :: self.mergeLists(a1=tail1, a2=lst2, a3=predicate)
           else
             head2 :: self.mergeLists(a1=lst1, a2=tail2, a3=predicate)
         )
        )
      in f(lst1=a1, lst2=a2, predicate=a3)

    # a1: list
    # a2: index 1
    # a3: index 2
    # returns a sublist with endpoints corresponding to the elements 
    # at index 1 and index 2.
    # If index2 is greater than the length of the list, then the function returns
    # element at index1 through last element in the list.
    # This function is used by mergeSort.
    getSublist(a1, a2:int, a3:int) =
      let f = 
        (fun lst:(`Nil ()), index1, index2 -> lst) &
        (fun lst:(`Hd head & `Tl tail), index1, index2 -> 
          if Common.isOneTrue(a1=Common.isGreaterThan(a1=index1, a2=index2),
                              a2=Common.isLessThan(a1=index1, a2=0)) then 
            `Nil () 
          else if Common.isGreaterThan(a1=index1, a2=0) then
            self.getSublist(a1=tail, a2=index1 - 1, a3=index2 - 1)
          else if index1 == index2 then
            head :: (`Nil ())
          else 
            head :: (self.getSublist(a1=tail, a2=index1, a3=index2 - 1))
        )
      in f(lst=a1, index1=a2, index2=a3)


    # a1: list
    # a2: comparison function
    # returns a sorted list, using merge-sort, where merging is performed
    # using the comparison function, as explained in mergeLists.
    mergeSort(a1, a2) =      
      let firstHalf = fun lst -> 
        self.getSublist(a1=a1, 
          a2=0, 
          a3=Common.divideInt(a1=self.getLength(a1=lst), a2=2) - 1) in
      let secondHalf = fun lst -> 
        self.getSublist(a1=a1, 
          a2=Common.divideInt(a1=self.getLength(a1=lst), a2=2),
          a3=self.getLength(a1=lst) - 1) in
      let f =
        (fun lst:(`Nil ()), comparisonFunc -> `Nil ()) &
        (fun lst:(`Hd head & `Tl `Nil ()), comparisonFunc -> lst) &
        (fun lst:(`Hd head1 & `Tl (`Hd head2 & `Tl tail)), comparisonFunc -> 
           self.mergeLists(a1=self.mergeSort(a1=firstHalf(lst=lst), a2=comparisonFunc),
             a2=self.mergeSort(a1=secondHalf(lst=lst), a2=comparisonFunc),
             a3=comparisonFunc))
      in f(lst=a1, comparisonFunc=a2)

  } in


#Common.append(a1=[1], a2=[2,3])
#LinkedList.getLength(a1=[1,2,3])
#LinkedList.getLength(a1=[])
#LinkedList.getHead(a1=[1,2,3])
#LinkedList.getHead(a1=[])
#LinkedList.getTail(a1=[1,2,3])
#LinkedList.getTail(a1=[])
#Common.negate(a1=`True ())
#Common.negate(a1=`False ())
#Common.isLessThan(a1=3, a2=2)
#Common.isLessThan(a1=-1, a2=2)
#Common.isGreaterThan(a1=3, a2=2)
#Common.isGreaterThan(a1=-1, a2=2)
#LinkedList.getElement(a1=[1,2,3], a2=0) # takes a long time to run
#LinkedList.getElement(a1=[1,2,3], a2=1) 
#LinkedList.getElement(a1=[1,2,3], a2=2) 
#LinkedList.getElement(a1=[1,2,3], a2=4)
#LinkedList.getElement(a1=[1,2,3], a2=-1)
#LinkedList.flatten(a1=[1,2,3]) 
#LinkedList.flatten(a1=[[1, 2],[3, 4]]) 
#let ff = (fun a1 -> a1 + 1) in LinkedList.map(a1=[1, 2, 3], a2=ff)
#let x = ref 0 in let ff = (fun a2 -> (fun a1 -> a2 <- !a2 + a1)) in LinkedList.iterate(a1=[1, 2, 3], a2=ff(a2=x)); !x 
#let ff = (fun a1, a2 -> a1 + a2) in LinkedList.foldLeft(a1=[1, 2, 3], a2=ff, a3=0)
#let ff = (fun a1, a2 -> a1 + a2) in LinkedList.foldRight(a1=[1, 2, 3], a2=ff, a3=0)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForAll(a1=[1, 1, 1], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForAll(a1=[1, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[1, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[2, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[2, 2, 2], a2=ff)
#LinkedList.contains(a1=[1,2,3], a2=2)
#LinkedList.contains(a1=[1,2,3], a2=4)
#LinkedList.mergeLists(a1=[2, 5, 8], a2=[0, 1, 4, 9], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[2, 5, 8], a2=[], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[], a2=[0, 1, 4, 9], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[], a2=[], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.getSublist(a1=[0, 1, 2, 3, 4, 5], a2=1, a3=7)
#Common.divideIntHelper(a1=0, a2=4, a3=2)
#Common.multDivIntHelper(a1=(), a2=4, a3=2)
#Common.divideInt(a1=4, a2=2)
#Common.divideInt(a1=0, a2=2)
#Common.divideInt(a1=-7, a2=2)
#Common.divideInt(a1=-1, a2=2)
#Common.divideInt(a1=8, a2=-2)
#Common.divideInt(a1=-7, a2=-2)
#Common.divideInt(a1=-7, a2=0)
#
#let cFunc = (fun a1:int, a2:int -> if a1 >= a2 then `False () else `True ()) in LinkedList.mergeSort(a1=[5, 2, 10, 11, 3, 14, 15, 0], a2=cFunc) # TODO: this takes a while to compute, even if typechecking is off.

#let nil = (`Nil ()) in let ff = (fun a1, a2 -> `Hd a1 & `Tl a2) in LinkedList.foldRight(a1=[1, 2, 3], a2=ff, a3=nil)

#let predicate = (fun a1 -> if Common.divideInt(a1=a1, a2=2) == 0 then `True () else `False ()) in LinkedList.filter(a1=[0, 2, 1, 3, 4, 5, 6, 7], a2=predicate)

#let ff = (fun a1 -> if Common.divideInt(a1=a1, a2=2) == 4 then `True () else `False ()) in LinkedList.find(a1=[3, 5, 7, 8, 9], a2=ff)

#let predicate = (fun a1, a2, a3 -> if a3 == 2 then `Hd (a1 + 2) & `Tl a2 else `Hd a1 & `Tl a2) in LinkedList.trackIndex(a1=[1, 2, 3, 4], a2=predicate, a3=0, a4=0)

#LinkedList.add(a1=[0, 1, 2], a2=3, a3=-1)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=0)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=1)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=2)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=3)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=10)

#LinkedList.remove(a1=[0, 1, 2], a2=-1)
#LinkedList.remove(a1=[0, 1, 2], a2=0)
#LinkedList.remove(a1=[0, 1, 2], a2=1)
#LinkedList.remove(a1=[0, 1, 2], a2=2)
#LinkedList.remove(a1=[0, 1, 2], a2=3)
#LinkedList.remove(a1=[0, 1, 2], a2=10)
;;


