# EXPECT-MATCHES: ()

# TODO: turn typechecking off to avoid performance delay while necessary.

# TODO: try to implement :: as a pattern to eliminate use of 
# `Head head & `Tl tail in fun arg patterns. Then, also replace `Nil () by [].

# TODO: carriage return after open parenthesis in function call 
# (e.g. application via arg list) has caused an error. Capture so it can be tested.

# TODO: function passing by name does not work directly (see divideInt comments).

# TODO: access nested objects.

let Common = 
  object {
    maxInt = 2147483647

    # a1: list
    # a2: list  
    append(a1, a2) = 
      let lst1 = a1 in
      let lst2 = a2 in
      let f = 
        ((fun lst1:(`Hd head & `Tl tail), lst2 -> 
            head :: (self.append(a1=tail, a2=lst2))) &
         (fun lst1:(`Nil ()), lst2 -> lst2))
      in f(lst1=a1, lst2=a2)

    #TODO: convert into LittleBang unary operator "not"
    # a1: boolean
    negate(a1) =
      let f = 
        ((fun arg1:(`True ())  -> `False ()) &
         (fun arg1:(`False ()) -> `True ()))
      in f(arg1=a1)

    #TODO: convert into LittleBang binary operator "and"
    # a1: boolean
    # a2: boolean
    areBothTrue(a1, a2) =
      let f = 
        ((fun arg1:(`True ()), arg2  -> if arg2 then `True () else `False ()) &
         (fun arg1:(`False ()), arg2 -> `False ()))
      in f(arg1=a1, arg2=a2)

    #TODO: convert into LittleBang binary operator "or"
    # a1: boolean
    # a2: boolean
    isOneTrue(a1, a2) =
      let f = 
        ((fun arg1:(`True ()), arg2  -> `True ()) &
         (fun arg1:(`False ()), arg2 -> arg2))
      in f(arg1=a1, arg2=a2)

    #TODO: convert into LittleBang binary operator "<"
    isLessThan(a1:int, a2:int) =
      let b1 = (a1 >= a2) in
      if self.negate(a1=b1) then `True ()
      else `False ()

    #TODO: convert into LittleBang binary operator ">"
    isGreaterThan(a1:int, a2:int) =
      let b1 = (a1 <= a2) in
      if self.negate(a1=b1) then `True ()
      else `False ()

    #TODO: replace explicit reference to self.divideIntHelper with func if possible.
    # Helper for int multiplication and division.
    # a1: helper function
    # a2: param 1
    # a3: param 2
    multDivIntHelper(a1, a2:int, a3:int) =
      let func = a1 in
      let param1 = a2 in
      let param2 = a3 in
      if param1 == 0 then 0
      else
        let bothPos = self.areBothTrue(a1=self.isLessThan(a1=0, a2=param1),
                                       a2=self.isLessThan(a1=0, a2=param2)) in
        let bothNeg = self.areBothTrue(a1=self.isGreaterThan(a1=0, a2=param1),
                                       a2=self.isGreaterThan(a1=0, a2=param2)) in
        if self.isOneTrue(a1=bothPos, a2=bothNeg) then
          if self.isLessThan(a1=0, a2=param1) then
            func(a1=0, a2=param1, a3=param2)
          else
            func(a1=0, a2=0 - param1, a3=0 - param2)
        else
          if self.isGreaterThan(a1=0, a2=param1) then
            0 - func(a1=0, a2=0 - param1, a3=param2)
          else
            0 - func(a1=0, a2=param1, a3=0 - param2)

    divideIntHelper(a1:int, a2:int, a3:int) =
      let count = a1 in
      let subtraction = a2 in
      let subtractor = a3 in
      if self.isLessThan(a1=subtraction, a2=subtractor) then
        count
      else
        self.divideIntHelper(
                             a1=(count + 1), 
                             a2=(subtraction - subtractor), 
                             a3=subtractor)

    #TODO: replace () with self.divideIntHelper if possible.
    #TODO: convert into LittleBang binary operator "/"
    # This goes into an infinite loop when division is by zero.
    divideInt(a1:int, a2:int) =
      let param1 = a1 in
      let param2 = a2 in
      let f = (fun a1, a2, a3 -> self.divideIntHelper(a1=a1, a2=a2, a3=a3)) in
      self.multDivIntHelper(a1=f, a2=param1, a3=param2)
    
    modIntHelperHelper(a1, a2:int, a3:int) =
      let multDivHelper = a1 in
      let param1 = a2 in
      let param2 = a3 in
      if param1 == 0 then 0
      else
        let bothPos = self.areBothTrue(a1=self.isLessThan(a1=0, a2=param1),
                                       a2=self.isLessThan(a1=0, a2=param2)) in
        let bothNeg = self.areBothTrue(a1=self.isGreaterThan(a1=0, a2=param1),
                                       a2=self.isGreaterThan(a1=0, a2=param2)) in
        if self.isOneTrue(a1=bothPos, a2=bothNeg) then
          if self.isLessThan(a1=0, a2=param1) then
            multDivHelper(a1=0, a2=param1, a3=param2)
          else
            multDivHelper(a1=0, a2=0 - param1, a3=0 - param2)
        else
          if self.isGreaterThan(a1=0, a2=param1) then
            if (0 - multDivHelper(a1=0, a2=0 - param1, a3=param2)) == 0 then
              0 - multDivHelper(a1=0, a2=0 - param1, a3=param2)
            else
              param2 - multDivHelper(a1=0, a2=0 - param1, a3=param2)
          else
            if (0 - multDivHelper(a1=0, a2=param1, a3=0 - param2)) == 0 then
              multDivHelper(a1=0, a2=param1, a3=0 - param2)
            else
              0 - param2 - multDivHelper(a1=0, a2=param1, a3=0 - param2)

    modIntHelper(a1:int, a2:int, a3:int) =
      let count = a1 in
      let subtraction = a2 in
      let subtractor = a3 in
      if self.isLessThan(a1=subtraction, a2=subtractor) then
        subtraction
      else
        self.modIntHelper(
                             a1=(count + 1), 
                             a2=(subtraction - subtractor), 
                             a3=subtractor)

    modInt(a1:int, a2:int) =
      let param1 = a1 in
      let param2 = a2 in
      let f = (fun a1, a2, a3 -> self.modIntHelper(a1=a1, a2=a2, a3=a3)) in
      self.modIntHelperHelper(a1=f, a2=param1, a3=param2)

    #TODO: other common binary operators that could be implemented: "*", bit-wise operators (including shift).  

  } in 


let LinkedList =
  object {
    # a1: list
    # returns the length of the list.
    getLength(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> 1 + (self.getLength(a1=tail))) &
         (fun arg1:(`Nil ()) -> 0))
      in f(arg1=a1)

    # a1: list
    # returns the head of the list, or a failure message if the list is empty.
    getHead(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> head) &
         (fun arg1:(`Nil ()) -> `Failure ()))
      in f(arg1=a1)

    # a1: list
    # returns the tail of the list, or a failure message if the list is empty.
    getTail(a1) =
      let f = 
        ((fun arg1:(`Hd head & `Tl tail) -> tail) &
         (fun arg1:(`Nil ()) -> `Failure ()))
      in f(arg1=a1)

    # a1: list
    # a2: index
    # returns the element in list at input index, or a failure message if not found.
    getElement(a1, a2:int) =
      let lst = a1 in
      let index = a2 in
      if Common.isLessThan(a1=index, a2=0) then `Failure ()
      else 
        let f = 
          ((fun lst:(`Hd head & `Tl tail) -> 
              if index == 0 then head
              else self.getElement(a1=tail, a2=index - 1)
           ) &
           (fun lst:(`Nil ()) -> `Failure ()))
        in f(lst=a1)

    # a1: list
    # returns a list consisting of all elements in member lists of 
    # the original list, in successive order, but now contained in 
    # the return list only.
    flatten(a1) =
      let lst = a1 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) -> Common.append(a1=head, 
                                             a2=(self.flatten(a1=tail)))) &
         (fun lst:(`Nil ()) -> lst))
      in f(lst=a1)      

    # a1: list
    # a2: fun
    # returns a new list consisting of fun applied to each element 
    # in an input list.
    map(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
           (func(a1=head)) :: (self.map(a1=tail, a2=func))) &
         (fun lst:(`Nil ()), func -> lst))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: fun
    # applies fun to each element in list, successively, and returns 
    # the result of applying fun to the last element in list.
    iterate(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            func(a1=head); self.iterate(a1=tail, a2=func)) &
         (fun lst:(`Nil ()), func -> ()))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: fun
    # a3: acc
    # returns the accrued value of successive applications of fun to 
    # each element in list, from left to right, each of which also 
    # takes the prior application's result, which is initially acc.
    foldLeft(a1, a2, a3:int) = 
      let lst = a1 in
      let func = a2 in
      let acc = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc -> 
            self.foldLeft(a1=tail, a2=func, a3=func(a1=head, a2=acc))) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3)

    # a1: list
    # a2: fun
    # a3: acc
    # returns the accrued value of successive applications of fun 
    # to each element in list, from right to left, each of which also 
    # takes the prior application's result, which is initially acc.
    foldRight(a1, a2, a3) = 
      let lst = a1 in
      let func = a2 in
      let acc = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc -> 
            func(a1=head, a2=self.foldRight(a1=tail, a2=func, a3=acc))) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3)

    # a1: list
    # a2: predicate
    # returns `True () if each element in list yields `True () 
    # as argument to predicate.
    isTrueForAll(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            Common.areBothTrue(a1=func(a1=head), 
                               a2=self.isTrueForAll(a1=tail, a2=func))
         ) &
         (fun lst:(`Nil ()), func -> `True ()))
      in f(lst=a1, func=a2)

    # a1: list
    # a2: predicate
    # returns `True () if at least one element in list yields `True () 
    # as argument to predicate.
    isTrueForOne(a1, a2) = 
      let lst = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func -> 
            if func(a1=head) then `True ()
            else self.isTrueForOne(a1=tail, a2=func)) &
         (fun lst:(`Nil ()), func -> `False ()))
      in f(lst=a1, func=a2)

    # TODO: allow this function to take elements of more types.
    # a1: list
    # a2: element (int)
    # returns `True () if element is contained in list, `False () otherwise.
    contains(a1, a2) = 
      let lst = a1 in
      let elem = a2 in
      let f = 
        (
         (fun lst:(`Hd head & `Tl tail), elem:int -> 
            if head == elem then `True ()
            else self.contains(a1=tail, a2=elem)) &

         (fun lst:(`Nil ()), elem -> `False ())
        )
      in f(lst=a1, elem=a2)

    # a1: list
    # a2: predicate
    # returns element in the list which, as argument to the predicate, 
    # yields `True (); fails if element is not found.
    find(a1, a2) =
      let f = 
        ((fun lst:(`Hd head & `Tl tail), predicate -> 
            if predicate(a1=head) then head
            else self.find(a1=tail, a2=predicate)) &
         (fun lst:(`Nil ()), predicate -> `Failure ()))
      in f(lst=a1, predicate=a2)

    # performs the action specified by func (which can be at a specific index) while being able to track current
    # index; traverses a list in foldRight fashion.
    trackIndex(a1, a2, a3, a4) = 
      let f = 
        ((fun lst:(`Hd head & `Tl tail), func, acc, currentIndex ->
            func(a1=head, a2=self.trackIndex(a1=tail, a2=func, a3=acc, a4=currentIndex+1), a3=currentIndex)
         ) &
         (fun lst:(`Nil ()), func, acc -> acc))
      in f(lst=a1, func=a2, acc=a3, currentIndex = a4)

    # a1: list
    # a2: predicate
    filter(a1, a2) =
      let p = a2 in
      let pred = (fun a1, a2 -> if p(a1=a1) then a1 :: a2 else a2) in 
      let f =
        ((fun lst:(`Hd head & `Tl tail), predicate -> 
            self.foldRight(a1=lst, a2=predicate, a3=[])) &
         (fun lst:(`Nil ()), predicate -> `Failure ()))
      in f(lst=a1, predicate=pred)

    # a1: list
    # a2: element
    # a3: index
    # performs index validity check and calls trackIndex.
    opHelper(a1, a2, a3) =
      let lst = a1 in
      let index = a2 in
      let predicate = a3 in
      if Common.isLessThan(a1=index, a2=0) then `Failure ()
      else if self.getLength(a1=lst) <= index then `Failure ()
      else 
        let f = 
          ((fun lst:(`Hd head & `Tl tail) -> 
              self.trackIndex(a1=lst, a2=predicate, a3=[], a4=0)
           ) &
           (fun lst:(`Nil ()) -> `Failure ()))
        in f(lst=a1)

    # a1: list
    # a2: element
    # a3: index
    # returns a list with element inserted at index.
    add(a1, a2, a3) =
      let lst = a1 in
      let elem = a2 in
      let index = a3 in
      if index == 0 then elem :: lst
      else
        let predicate = (fun a1, a2, a3 -> if a3 == index then elem :: a1 :: a2 else a1 :: a2) in
        self.opHelper(a1=lst, a2=index, a3=predicate)

    # a1: list
    # a2: index
    # returns a list with element at index updated.
    update(a1, a2, a3) =
      let lst = a1 in
      let elem = a2 in
      let index = a3 in
      if index == 0 then
        let f = 
          (fun lst:(`Hd head & `Tl tail) -> 
              elem :: tail
          ) in f(lst=a1)
      else
        let predicate = (fun a1, a2, a3 -> if a3 == index then elem :: a2 else a1 :: a2) in
        self.opHelper(a1=lst, a2=index, a3=predicate)

    # a1: list
    # a2: index
    # returns a list with element at index removed.
    remove(a1, a2) =
      let lst = a1 in
      let index = a2 in
      if index == 0 then
        let f = 
          (fun lst:(`Hd head & `Tl tail) -> 
              tail
          ) in f(lst=a1)
      else
        let predicate = (fun a1, a2, a3 -> if a3 == index then a2 else a1 :: a2) in
        self.opHelper(a1=lst, a2=index, a3=predicate)

    # This function is used by mergeSort.
    # a1: list
    # a2: list
    # a3: predicate fun
    # returns a list consisting of the merging of the two input lists, 
    # where the heads of each list are compared using predicate fun, 
    # with the element on the left argument to predicate fun being 
    # selected for merging if it yields `True (), and the element on the 
    # right being selected otherwise.
    mergeLists(a1, a2, a3) =
      let f =
        ((fun lst1:(`Nil ()), lst2:(`Nil ()), predicate -> `Nil ()
         ) &
         (fun lst1:(`Nil ()), lst2:(`Hd head & `Tl tail), predicate -> lst2
         ) &
         (fun lst1:(`Hd head & `Tl tail), lst2:(`Nil ()), predicate -> lst1
         ) &
         (fun lst1:(`Hd head1 & `Tl tail1), lst2:(`Hd head2 & `Tl tail2), predicate ->
           if predicate(a1=head1, a2=head2) then
             head1 :: self.mergeLists(a1=tail1, a2=lst2, a3=predicate)
           else
             head2 :: self.mergeLists(a1=lst1, a2=tail2, a3=predicate)
         )
        )
      in f(lst1=a1, lst2=a2, predicate=a3)

    # a1: list
    # a2: index 1
    # a3: index 2
    # returns a sublist with endpoints corresponding to the elements 
    # at index 1 and index 2.
    # If index2 is greater than the length of the list, then the function returns
    # element at index1 through last element in the list.
    # This function is used by mergeSort.
    getSublist(a1, a2:int, a3:int) =
      let f = 
        (fun lst:(`Nil ()), index1, index2 -> lst) &
        (fun lst:(`Hd head & `Tl tail), index1, index2 -> 
          if Common.isOneTrue(a1=Common.isGreaterThan(a1=index1, a2=index2),
                              a2=Common.isLessThan(a1=index1, a2=0)) then 
            `Nil () 
          else if Common.isGreaterThan(a1=index1, a2=0) then
            self.getSublist(a1=tail, a2=index1 - 1, a3=index2 - 1)
          else if index1 == index2 then
            head :: (`Nil ())
          else 
            head :: (self.getSublist(a1=tail, a2=index1, a3=index2 - 1))
        )
      in f(lst=a1, index1=a2, index2=a3)


    # a1: list
    # a2: comparison function
    # returns a sorted list, using merge-sort, where merging is performed
    # using the comparison function, as explained in mergeLists.
    mergeSort(a1, a2) =      
      let firstHalf = fun lst -> 
        self.getSublist(a1=a1, 
          a2=0, 
          a3=Common.divideInt(a1=self.getLength(a1=lst), a2=2) - 1) in
      let secondHalf = fun lst -> 
        self.getSublist(a1=a1, 
          a2=Common.divideInt(a1=self.getLength(a1=lst), a2=2),
          a3=self.getLength(a1=lst) - 1) in
      let f =
        (fun lst:(`Nil ()), comparisonFunc -> `Nil ()) &
        (fun lst:(`Hd head & `Tl `Nil ()), comparisonFunc -> lst) &
        (fun lst:(`Hd head1 & `Tl (`Hd head2 & `Tl tail)), comparisonFunc -> 
           self.mergeLists(a1=self.mergeSort(a1=firstHalf(lst=lst), a2=comparisonFunc),
             a2=self.mergeSort(a1=secondHalf(lst=lst), a2=comparisonFunc),
             a3=comparisonFunc))
      in f(lst=a1, comparisonFunc=a2)

  } in

# This is a simple list-based array object used for building a hash table.
let ListArray = 
  object {
    maxCapacity = Common.maxInt 

    createHelper(a1:int, a2, a3)=
      let len = a1 in
      let lst = a2 in
      let pseudotype = a3 in
      let temp = ref () in temp <- pseudotype;
      if len >= 1 then self.createHelper(a1=len - 1, a2=temp::lst, a3=pseudotype) 
      else lst
      
    # a1: int (initial capacity)
    # a2: pseudo-type
    # returns a list array with elements consisting of ref pseudo-type.
    create(a1:int, a2) =
      let len = a1 in
      let pseudotype = a2 in
      if (len + 1) <= 0 then `Failure ()
      else 
        let len =
          if len >= self.maxCapacity then self.maxCapacity else len
        in
        self.createHelper(a1=len, a2=[], a3=[])
   
    # a1: array 1
    # a2: array 2
    # returns an array consisting of array 2 copied onto array 1, starting at index 0.
    copy(a1, a2) =
      let arr1 = a1 in
      let arr2 = a2 in
      let arr1Len = LinkedList.getLength(a1=arr1) in
      let arr2Len = LinkedList.getLength(a1=arr2) in
      Common.append(a1=arr2, a2=LinkedList.getSublist(a1=arr1, a2=arr2Len, a3=arr1Len - 1))

  } in

# TODO: to implement getHashCode on objects, one possibility is for the object to have an equatable field, 
# which is a field containing a set of strings of names of object fields which are to be equated to another
# object's corresponding fields. 
# Then the getHashCode function recursively looks into 
# fields named in the set and builds a hashCode by arriving at fields which can be equated using == (such as
# boolean, int, char, and string).
# If two objects' equatable fields have the same set of strings, then an equals function can recursively
# look into the fields and compare the objects.
let HashMap = 
  object {
    initialCapacity = ref 10 #TODO: update this
    maxCapacity = ref 100 #TODO: update this

    #TODO: use of self is not allowed, unless an argument is added.
#    createDefault = 
#      let array = ListArray.create(a1=self.initialCapacity) in
#      object{hashedArray=array capacityRef=(ref !(self.initialCapacity)) sizeRef=(ref 0)}

    # a1: capacity
    # returns a hash map
    create(a1:int) =
      let capacity = a1 in 
      if capacity <= 0 then `Failure ()
      else if capacity >= !self.maxCapacity + 1 then `Failure ()
      else 
        let capacity =
          if capacity <= (!self.initialCapacity - 1) then 
            self.initialCapacity
          else capacity 
        in let array = ListArray.create(a1=capacity, a2=[]) in
        object{hashedArray=array capacityRef=(ref capacity) sizeRef=(ref 0)}

    # a1: HashMap
    # a2: key
    # returns the hashed index for the key.
    getHashIndex(a1, a2) =
      let hashMap = a1 in
      let key = a2 in
      let hashCode = key in #TODO: replace this by "getHashCode key" once getHashCode is available.
      #TODO: possibly do bitwise manipulation on hashCode to get a more uniform hash code.
      Common.modInt(a1=hashCode, a2=!hashMap.capacityRef)

    # a1: HashMap
    # a2: key
    # returns a reference to a list of pairs at the hashed index obtained from the key.
    getIndexListRef(a1, a2) =
      let hashMap = a1 in
      let key = a2 in
      let keyIndex = self.getHashIndex(a1=hashMap, a2=key) in
      let array = hashMap.hashedArray in array[keyIndex] 

    # a1: HashMap
    # a2: key
    # a3: element
    # adds an element to the hash map; returns ().
    addElement(a1, a2:int, a3) = #TODO: eventually remove the a2:int constraint.
      let hashMap = a1 in 
      let key = a2 in
      let elem = a3 in
      let indexListRef = self.getIndexListRef(a1=hashMap, a2=key) in 
      indexListRef <- [key, elem] :: !indexListRef;
      hashMap.sizeRef <- !hashMap.sizeRef + 1
    
    # a1: HashMap
    # a2: key 
    # returns the element with key "key".
    getElement(a1, a2:int) = #TODO: eventually remove the a2:int constraint.
      let hashMap = a1 in
      let key = a2 in
      let indexList = !self.getIndexListRef(a1=hashMap, a2=key) in
      let predicate = fun a1:[x,y] -> if x == key then `True () else `False () in
      let pair = LinkedList.find(a1=indexList, a2=predicate) in
      let f = 
        (fun p:(`Hd head & `Tl tail) -> pair[1]) &
        (fun p:() -> `Failure ()) in f(p=pair)

    # a1: list
    # a2: key
    removeKeyHelper(a1, a2:int) = #TODO: eventually remove the a2:int constraint.
      let lst = a1 in
      let key = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
            let k = head[0] in  
            if k == key then tail 
            else `Hd head & `Tl self.removeKeyHelper(a1=tail, a2=key)
         ) &
         (fun lst:(`Nil ()) -> lst))
      in f(lst=lst)

    # a1: HashMap
    # a2: key
    # removes the element with key "key"; returns ().
    removeKey(a1, a2:int) = #TODO: eventually remove the a2:int constraint.
      let hashMap = a1 in
      let key = a2 in
      let indexListRef = self.getIndexListRef(a1=hashMap, a2=key) in
      let predicate = fun a1:[x,y] -> if x == key then `True () else `False () in
      if LinkedList.isTrueForOne(a1=!indexListRef, a2=predicate) then
        indexListRef <- self.removeKeyHelper(a1=!indexListRef, a2=key);
        hashMap.sizeRef <- !hashMap.sizeRef - 1
      else ()

    # a1: list
    # a2: key
    containsKeyHelper(a1, a2:int) = #TODO: eventually remove the a2:int constraint.
      let indexList = a1 in
      let key = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
            let k = head[0] in  
            if k == key then `True () 
            else self.containsKeyHelper(a1=tail, a2=key)
         ) &
         (fun lst:(`Nil ()) -> `False ()))
      in f(lst=indexList)

    # a1: HashMap
    # a2: key
    # returns true if the hash map contains the pair with key "key".
    containsKey(a1, a2:int) = #TODO: eventually remove the a2:int constraint.
      let hashMap = a1 in
      let key = a2 in
      let indexList = !self.getIndexListRef(a1=hashMap, a2=key) in
      self.containsKeyHelper(a1=indexList, a2=key)

    # a1: list of pair lists
    # a2: list of pairs
    # a3: function
    findPairHelper(a1, a2, a3) = 
      let lstIndexes = a1 in
      let lstPairs = a2 in
      let predicate = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
            if predicate(a1=head) then head
            else self.findPairHelper(a1=lstIndexes, a2=tail, a3=predicate)
         ) &
         (fun lst:(`Nil ()) -> 
            let f2 =
              ((fun lst2:(`Hd head & `Tl tail) ->
                self.findPairHelper(a1=tail, a2=!head, a3=predicate)
               ) &
               (fun lst2:(`Nil ()) ->
                 `Failure ()
               ))
            in f2(lst2=lstIndexes)
         ))
      in f(lst=lstPairs)

    # a1: HashMap
    # a2: predicate
    # returns the pair that meets the predicate.
    findPair(a1, a2) = 
      let hashMap = a1 in
      let predicate = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
          self.findPairHelper(a1=tail, a2=!head, a3=predicate)
         ) &
         (fun lst:(`Nil ()) ->
           `Failure ()
        ))
      in f(lst=hashMap.hashedArray)  

    # a1: list of pair lists
    # a2: list of pairs
    # a3: function applied to values
    iterateHelper(a1, a2, a3) = 
      let lstIndexes = a1 in
      let lstPairs = a2 in
      let func = a3 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
            func(a1=head);
            self.iterateHelper(a1=lstIndexes, a2=tail, a3=func)
         ) &
         (fun lst:(`Nil ()) -> 
            let f2 =
              ((fun lst2:(`Hd head & `Tl tail) ->
                self.iterateHelper(a1=tail, a2=!head, a3=func)
               ) &
               (fun lst2:(`Nil ()) ->
                 ()
               ))
            in f2(lst2=lstIndexes)
         ))
      in f(lst=lstPairs)

    # a1: HashMap
    # a2: function
    # iterates through the key-value pairs, applying the function to each pair, returning ().
    iterate(a1, a2) =
      let hashMap = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
          self.iterateHelper(a1=tail, a2=!head, a3=func)
         ) &
         (fun lst:(`Nil ()) ->
           ()
        ))
      in f(lst=hashMap.hashedArray)  

    # a1: HashMap
    # a2: size
    # returns a new hash map of size "size", with the key-value pairs in the old hash map.
    resize(a1, a2:int) =
      let oHashMap = a1 in
      let nHashMap = self.create(a1=a2) in
      let func =
        (fun a1:[k,e] -> self.addElement(a1=nHashMap, a2=k, a3=e))
      in self.iterate(a1=oHashMap, a2=func); nHashMap

    # a1: list of pair lists
    # a2: list of pairs
    # a3: function applied to values
    mapHelper(a1, a2) = 
      let lstIndexes = a1 in
      let func = a2 in
      let f = 
        ((fun lst:(`Hd head & `Tl tail) ->
            head <- LinkedList.map(a1=!head, a2=func);
            self.mapHelper(a1=tail, a2=func)
         ) &
         (fun lst:(`Nil ()) ->
            ()
         ))
      in f(lst=lstIndexes)

    # a1: HashMap
    # a2: function
    # maps the function to each key-value pair; returns ().
    map(a1, a2) =
      let hashMap = a1 in
      let func = a2 in
      self.mapHelper(a1=hashMap.hashedArray, a2=func)

    # a1: HashMap
    # returns the number of key-value pairs in the hash map.
    getNumberOfKeys(a1) =
      let hashMap = a1 in
      !hashMap.sizeRef

  } in

#f cons (e cons (d cons (c cons (b cons a))))

#Common.append(a1=[1], a2=[2,3])
#LinkedList.getLength(a1=[1,2,3])
#LinkedList.getLength(a1=[])
#LinkedList.getHead(a1=[1,2,3])
#LinkedList.getHead(a1=[])
#LinkedList.getTail(a1=[1,2,3])
#LinkedList.getTail(a1=[])
#Common.negate(a1=`True ())
#Common.negate(a1=`False ())
#Common.isLessThan(a1=3, a2=2)
#Common.isLessThan(a1=-1, a2=2)
#Common.isGreaterThan(a1=3, a2=2)
#Common.isGreaterThan(a1=-1, a2=2)
#LinkedList.getElement(a1=[1,2,3], a2=0) # takes a long time to run
#LinkedList.getElement(a1=[1,2,3], a2=1) 
#LinkedList.getElement(a1=[1,2,3], a2=2) 
#LinkedList.getElement(a1=[1,2,3], a2=4)
#LinkedList.getElement(a1=[1,2,3], a2=-1)
#LinkedList.flatten(a1=[1,2,3]) 
#LinkedList.flatten(a1=[[1, 2],[3, 4]]) 
#let ff = (fun a1 -> a1 + 1) in LinkedList.map(a1=[1, 2, 3], a2=ff)
#let x = ref 0 in let ff = (fun a2 -> (fun a1 -> a2 <- !a2 + a1)) in LinkedList.iterate(a1=[1, 2, 3], a2=ff(a2=x)); !x 
#let ff = (fun a1, a2 -> a1 + a2) in LinkedList.foldLeft(a1=[1, 2, 3], a2=ff, a3=0)
#let ff = (fun a1, a2 -> a1 + a2) in LinkedList.foldRight(a1=[1, 2, 3], a2=ff, a3=0)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForAll(a1=[1, 1, 1], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForAll(a1=[1, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[1, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[2, 1, 2], a2=ff)
#let ff = (fun a1 -> a1 == 1) in LinkedList.isTrueForOne(a1=[2, 2, 2], a2=ff)
#LinkedList.contains(a1=[1,2,3], a2=2)
#LinkedList.contains(a1=[1,2,3], a2=4)
#LinkedList.mergeLists(a1=[2, 5, 8], a2=[0, 1, 4, 9], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[2, 5, 8], a2=[], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[], a2=[0, 1, 4, 9], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.mergeLists(a1=[], a2=[], a3=(fun a1, a2 -> if a1 >= a2 then `False() else `True()))
#LinkedList.getSublist(a1=[0, 1, 2, 3, 4, 5], a2=1, a3=7)
#Common.divideIntHelper(a1=0, a2=4, a3=2)
#Common.multDivIntHelper(a1=(), a2=4, a3=2)
#Common.divideInt(a1=4, a2=2)
#Common.divideInt(a1=0, a2=2)
#Common.divideInt(a1=-7, a2=2)
#Common.divideInt(a1=-1, a2=2)
#Common.divideInt(a1=8, a2=-2)
#Common.divideInt(a1=-7, a2=-2)
#Common.divideInt(a1=-7, a2=0)
#
#let cFunc = (fun a1:int, a2:int -> if a1 >= a2 then `False () else `True ()) in LinkedList.mergeSort(a1=[5, 2, 10, 11, 3, 14, 15, 0], a2=cFunc) # TODO: this takes a while to compute, even if typechecking is off.

#let nil = (`Nil ()) in let ff = (fun a1, a2 -> `Hd a1 & `Tl a2) in LinkedList.foldRight(a1=[1, 2, 3], a2=ff, a3=nil)

#let predicate = (fun a1 -> if Common.divideInt(a1=a1, a2=2) == 0 then `True () else `False ()) in LinkedList.filter(a1=[0, 2, 1, 3, 4, 5, 6, 7], a2=predicate)

#let ff = (fun a1 -> if Common.divideInt(a1=a1, a2=2) == 4 then `True () else `False ()) in LinkedList.find(a1=[3, 5, 7, 8, 9], a2=ff)

#let predicate = (fun a1, a2, a3 -> if a3 == 2 then `Hd (a1 + 2) & `Tl a2 else `Hd a1 & `Tl a2) in LinkedList.trackIndex(a1=[1, 2, 3, 4], a2=predicate, a3=0, a4=0)

#LinkedList.add(a1=[0, 1, 2], a2=3, a3=-1)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=0)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=1)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=2)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=3)
#LinkedList.add(a1=[0, 1, 2], a2=3, a3=10)

#LinkedList.update(a1=[0, 1, 2], a2=3, a3=0)
#LinkedList.update(a1=[0, 1, 2], a2=3, a3=1)

#LinkedList.remove(a1=[0, 1, 2], a2=-1)
#LinkedList.remove(a1=[0, 1, 2], a2=0)
#LinkedList.remove(a1=[0, 1, 2], a2=1)
#LinkedList.remove(a1=[0, 1, 2], a2=2)
#LinkedList.remove(a1=[0, 1, 2], a2=3)
#LinkedList.remove(a1=[0, 1, 2], a2=10)

#ListArray.create(a1=3, a2=())
#let arr1 = ListArray.create(a1=3, a2=()) in 
#  arr1[0] <- 100; 
#  arr1[1] <- 200; 
#  arr1[2] <- 300; 
#  let arr2 = ListArray.create(a1=2, a2=()) in 
#  arr2[0] <- 400; 
#  arr2[1] <- 500; 
#  ListArray.copy(a1=arr1, a2=arr2)

#let x = ref () in x <- []; x::x::[]
#HashMap.create(a1=5)
#Common.modInt(a1=1, a2=3)
#HashMap.getHashIndex(a1=HashMap.create(a1=5), a2=2)
#HashMap.getHashIndex(a1=HashMap.create(a1=3), a2=-1)

#let hashMap = HashMap.create(a1=3) in HashMap.addElement(a1=hashMap, a2=-1, a3=-5); hashMap

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  hashMap

#let key = 1 in let predicate = fun a1:[x,y] -> if x == key then `True () else `False () in
#  LinkedList.find(a1=[[4, 400], [1, 100]], a2=predicate)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  HashMap.getElement(a1=hashMap, a2=1)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  HashMap.getElement(a1=hashMap, a2=10)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  HashMap.containsKey(a1=hashMap, a2=3)

#let l = ref 0 in l <- [[1,100],[2,200]]; HashMap.removeKeyHelper(a1=!l, a2=2)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  let key = 1 in
#  HashMap.removeKey(a1=hashMap, a2=key); hashMap

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  HashMap.removeKey(a1=hashMap, a2=2); 
#  HashMap.removeKey(a1=hashMap, a2=4);
#  HashMap.removeKey(a1=hashMap, a2=0);
#  HashMap.removeKey(a1=hashMap, a2=1);
#  hashMap

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  HashMap.getNumberOfKeys(a1=hashMap)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  let predicate = fun a1:[x,y] -> if x == 1 then `True () else `False () in
#  HashMap.findPair(a1=hashMap, a2=predicate)

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  let x = ref 0 in let ff = (fun a2 -> (fun a1:[k,e] -> a2 <- !a2 + e)) in 
#  HashMap.iterate(a1=hashMap, a2=ff(a2=x)); !x

#let hashMap = HashMap.create(a1=3) in 
#  HashMap.addElement(a1=hashMap, a2=0, a3=0);
#  HashMap.addElement(a1=hashMap, a2=1, a3=100);
#  HashMap.addElement(a1=hashMap, a2=2, a3=200);
#  HashMap.addElement(a1=hashMap, a2=4, a3=400);
#  let ff = (fun a1:[k,e] -> [k,1 + e]) in 
#  HashMap.map(a1=hashMap, a2=ff); hashMap

let hashMap = HashMap.create(a1=3) in 
  HashMap.addElement(a1=hashMap, a2=0, a3=0);
  HashMap.addElement(a1=hashMap, a2=1, a3=100);
  HashMap.addElement(a1=hashMap, a2=2, a3=200);
  HashMap.addElement(a1=hashMap, a2=4, a3=400);
  HashMap.resize(a1=hashMap, a2=5)
;;


