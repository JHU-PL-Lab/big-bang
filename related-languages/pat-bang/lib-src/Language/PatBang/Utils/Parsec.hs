{-# LANGUAGE TemplateHaskell #-}

{-|
  This module contains an assortment of Parsec-related utilities.
-}
module Language.PatBang.Utils.Parsec
( (</>)
, packrat
, (<@>)
, conditional
, (?=>)
, conditionalDiscard
, (?+>)
, eps
) where

import Control.Applicative ((*>),(<*),(<*>))
import Text.Parsec.Prim

import Language.PatBang.Display hiding ((</>))
import Language.PatBang.Logging

$(loggingFunctions)

-- |A binary packrat parser operation.  The first parser is attempted; if it
--  fails, it consumes no input and the second parser is used instead.
packrat :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
packrat a b = try a <|> b

-- |An infix alias for @packrat@.
(</>) :: ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
(</>) = packrat
infixl 1 </>

-- |A combinator which is used for conditional parsing.  This function takes a
--  parser producing a function and another parser producing the argument of
--  that function.  If the first parser does not match, the entire parser
--  consumes no input.  If the first parser does match, the parse is committed
--  and the second parser is used to produce an argument for the function
--  generated by the first parser.
conditional :: ParsecT s u m (a -> b) -> ParsecT s u m a -> ParsecT s u m b
conditional a b = try a <*> b

-- |An infix alias for @conditional@.  This operator is at the same fixity as
--  @<$>@ and @<*>@ so it can be used in sequences.
(?=>) :: ParsecT s u m (a -> b) -> ParsecT s u m a -> ParsecT s u m b
(?=>) = conditional
infixl 4 ?=>

-- |A form of @conditional@ which does not expect a useful argument to its
--  immediate right.  Instead, the second parser's argument is discarded.
conditionalDiscard :: ParsecT s u m a -> ParsecT s u m b -> ParsecT s u m a
conditionalDiscard a b = try a <* b

-- |An infix alias for @conditionalDiscard@.  @?+>@ is to @<*@ as @?=>@ is to
--  @<*>@.
(?+>) :: ParsecT s u m a -> ParsecT s u m b -> ParsecT s u m a
(?+>) = conditionalDiscard
infixl 4 ?+>

-- |A parser which always succeeds, returning unit.  This is equivalent to
--  @return ()@.  It is particularly useful as an alternative to @try@
--  expressions: @try (foo <$> bar <*> baz)@ is equivalent to
--  @foo <$> bar <*> baz ?+> eps@.  (@eps@ is short for "epsilon").
eps :: ParsecT s u m ()
eps = return ()

-- |Wraps a parser in a debug logger.  This logger will log messages when the
--  parser starts, succeeds, or fails.  The first argument to this function is
--  a description of the parser in question.
loggingParser :: (Monad m, Display a)
              => String -> ParsecT s u m a -> ParsecT s u m a
loggingParser desc p = do
  st <- getParserState
  _debug $ "Trying " ++ desc ++ " at "  ++ show (statePos st)
  result <- p <|> _debug ("Failed to parse " ++ desc ++ " at "
                      ++ show (statePos st))
                  *> parserZero
  _debug $ "Parsed " ++ desc ++ " at " ++ show (statePos st) ++ ": "
              ++ display result
  return result
  
-- |An infix synonym for @loggingParser@.
(<@>) :: (Monad m, Display a) => String -> ParsecT s u m a -> ParsecT s u m a
(<@>) = loggingParser
infixl 0 <@>
